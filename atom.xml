<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浣熊窝</title>
  <subtitle>Hello, world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://whaoyu.com/"/>
  <updated>2017-01-20T09:29:27.000Z</updated>
  <id>http://whaoyu.com/</id>
  
  <author>
    <name>浣熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenWRT开发：Helloworld</title>
    <link href="http://whaoyu.com/2017/01/20/openwrt-helloworld/"/>
    <id>http://whaoyu.com/2017/01/20/openwrt-helloworld/</id>
    <published>2017-01-20T09:09:27.000Z</published>
    <updated>2017-01-20T09:29:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译SDK"><a href="#编译SDK" class="headerlink" title="编译SDK"></a>编译SDK</h2><p>通过SDK方式开发OpenWRT，可以节省编译的时间。</p>
<h3 id="配置Makefile"><a href="#配置Makefile" class="headerlink" title="配置Makefile"></a>配置Makefile</h3><p>在OpenWRT源码中，执行以下命令，选中 [*]Build the OpenWrt SDK,保存退出。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make menuconfig</div></pre></td></tr></table></figure></p>
<p><img src="/2017/01/20/openwrt-helloworld/1.jpg" alt=""></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>执行以下命令，SDK会保存在以下位置<code>openwrt-hc5x61/openwrt-ramips/bin/ramips/OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2</code>。</p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>执行以下命令，解压SDK，并进入目录<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar -jxvf OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2</div><div class="line"><span class="built_in">cd</span> OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2</div></pre></td></tr></table></figure></p>
<h2 id="编写Helloworld"><a href="#编写Helloworld" class="headerlink" title="编写Helloworld"></a>编写Helloworld</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">openwrt-SDK/package/helloworld</div><div class="line">├── Makefile</div><div class="line">└── src</div><div class="line">    ├── helloworld<span class="selector-class">.c</span></div><div class="line">    └── Makefile</div></pre></td></tr></table></figure>
<h3 id="外层Makefile"><a href="#外层Makefile" class="headerlink" title="外层Makefile"></a>外层Makefile</h3><figure class="highlight mk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">include $(TOPDIR)/rules.mk</div><div class="line"></div><div class="line">PKG_NAME:=helloworld</div><div class="line">PKG_RELEASE:=1</div><div class="line"></div><div class="line">PKG_BUILD_DIR:=<span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(PKG_NAME)</span></div><div class="line"></div><div class="line">include $(INCLUDE_DIR)/package.mk</div><div class="line"></div><div class="line"></div><div class="line">define Package/helloworld</div><div class="line">	SECTION:=utils</div><div class="line">	CATEGORY:=Utilities</div><div class="line">	TITLE:=Helloworld</div><div class="line">endef</div><div class="line"></div><div class="line">define Build/Prepare</div><div class="line">	mkdir -p <span class="variable">$(PKG_BUILD_DIR)</span></div><div class="line">	<span class="variable">$(CP)</span> ./src/* <span class="variable">$(PKG_BUILD_DIR)</span>/</div><div class="line">endef</div><div class="line"></div><div class="line">define Package/helloworld/install</div><div class="line">	<span class="variable">$(INSTALL_DIR)</span> <span class="variable">$(1)</span>/bin</div><div class="line">	<span class="variable">$(INSTALL_BIN)</span> <span class="variable">$(PKG_BUILD_DIR)</span>/helloworld <span class="variable">$(1)</span>/bin/</div><div class="line">endef</div><div class="line"></div><div class="line">$(eval $(call BuildPackage,helloworld))</div></pre></td></tr></table></figure>
<h3 id="src-helloworld-c"><a href="#src-helloworld-c" class="headerlink" title="src/helloworld.c"></a>src/helloworld.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="src-Makefile"><a href="#src-Makefile" class="headerlink" title="src/Makefile"></a>src/Makefile</h3><figure class="highlight mk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">helloworld: helloworld.o</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> helloworld.o -o helloworld</div><div class="line">helloworld.o: helloworld.c</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c helloworld.c</div><div class="line"></div><div class="line"><span class="section">clean:</span></div><div class="line">	rm *.o helloworld</div></pre></td></tr></table></figure>
<h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>回到SDK根目录，然后编译，编译结果在<code>openwrt-SDK//bin/ramips/packages/base/</code>。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> openwrt-SDK</div><div class="line">make menuconfig </div><div class="line"><span class="comment"># 把Utilities里的helloworld要么打M, 要么打*</span></div><div class="line">make V=s</div></pre></td></tr></table></figure></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>将ipk文件上传到路由器，然后执行安装命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">opkg install helloworld_1_ramips_24kec.ipk</div></pre></td></tr></table></figure></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译SDK&quot;&gt;&lt;a href=&quot;#编译SDK&quot; class=&quot;headerlink&quot; title=&quot;编译SDK&quot;&gt;&lt;/a&gt;编译SDK&lt;/h2&gt;&lt;p&gt;通过SDK方式开发OpenWRT，可以节省编译的时间。&lt;/p&gt;
&lt;h3 id=&quot;配置Makefile&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="OpenWRT" scheme="http://whaoyu.com/categories/OpenWRT/"/>
    
    
      <category term="Helloworld" scheme="http://whaoyu.com/tags/Helloworld/"/>
    
      <category term="OpenWRT" scheme="http://whaoyu.com/tags/OpenWRT/"/>
    
  </entry>
  
  <entry>
    <title>编译OpenWRT</title>
    <link href="http://whaoyu.com/2017/01/19/make-openwrt/"/>
    <id>http://whaoyu.com/2017/01/19/make-openwrt/</id>
    <published>2017-01-19T08:22:02.000Z</published>
    <updated>2017-01-20T09:25:23.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><ul>
<li>Ubuntu 12.04 32bit</li>
<li>Windows Subsystem for Linux</li>
</ul>
<h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p>项目源码托管在GitHub上，地址如下：<strong><a href="https://github.com/rssnsj/openwrt-hc5x61" target="_blank" rel="external">openwrt-hc5x61</a></strong>。</p>
<p>本项目使用的是<a href="http://www.hiwifi.com/" target="_blank" rel="external">极路由</a>的极路由2路由器。</p>
<h2 id="前提工作"><a href="#前提工作" class="headerlink" title="前提工作"></a>前提工作</h2><ol>
<li><p>必装工具(仅限Debian和Ubuntu)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential git subversion wget flex gettext libncurses5-dev unzip gawk liblzma-dev zlib1g-dev ccache u-boot-tools</div></pre></td></tr></table></figure>
</li>
<li><p>Checkout项目代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/rssnsj/openwrt-hc5x61.git</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>注意：建议国内用户在编译过程中全程翻墙，因为会从国外下载一些额外的软件包。推荐使用<strong>proxychains</strong>，具体使用方法，请自行Google<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> openwrt-hc5x61</div><div class="line"><span class="comment"># 将hc5761(极2)设置为编译目标对象</span></div><div class="line">ln <span class="_">-s</span> ./config-hiwifi-hc5761 ./config-hiwifi</div><div class="line"><span class="comment"># 可自定义自己需要的额外功能</span></div><div class="line">make menuconfig</div><div class="line"><span class="comment"># 编译</span></div><div class="line">make</div></pre></td></tr></table></figure></p>
<p>编译成功后，目标文件在<code>openwrt-ramips/bin/ramips/openwrt-ramips-mt7620a-hc5761-squashfs-sysupgrade.bin</code></p>
<p><strong>注意1：</strong><br>编译过程中，会有一些组件下载失败，手动下载同名的文件放到<code>openwrt-ramips/dl</code>下面，再执行<code>make</code>继续编译。<br><strong>注意2：</strong><br>pdnsd组件原项目地址已经失效，请单独下载，注意切换分支。<br>文件名为：pdnsd-1.2.9a-par-a8e46ccba7b0fa2230d6c42ab6dcd92926f6c21d.tar.gz<br>commit Hash:a8e46ccba7b0fa2230d6c42ab6dcd92926f6c21d</p>
<h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 登录路由器(IP地址是路由器地址)</span></div><div class="line">ssh root@192.168.199.1</div><div class="line"><span class="built_in">cd</span> /tmp</div><div class="line"></div><div class="line"><span class="comment"># 替换U-boot以防止万一刷砖无法直接tftp刷root固件</span></div><div class="line"><span class="comment"># 已经替换的可以忽略，以极2为例，其他请参考项目文档</span></div><div class="line">wget http://rssn.cn/roms/uboot/HC5761-uboot.bin</div><div class="line">mtd write HC5761-uboot.bin u-boot</div><div class="line"></div><div class="line"><span class="comment"># 下载固件</span></div><div class="line"><span class="comment"># 可以通过FTP等方式，将刚刚生成的文件放到/tmp文件夹下</span></div><div class="line"></div><div class="line"><span class="comment"># 刷机</span></div><div class="line">sysupgrade -F -n openwrt-ramips-mt7620a-hc5761-squashfs-sysupgrade.bin</div></pre></td></tr></table></figure>
<h3 id="线刷"><a href="#线刷" class="headerlink" title="线刷"></a>线刷</h3><p>暂时没有工具，等工具来到后，补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译环境&quot;&gt;&lt;a href=&quot;#编译环境&quot; class=&quot;headerlink&quot; title=&quot;编译环境&quot;&gt;&lt;/a&gt;编译环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ubuntu 12.04 32bit&lt;/li&gt;
&lt;li&gt;Windows Subsystem for Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;项目源码&quot;&gt;&lt;a href=&quot;#项目源码&quot; class=&quot;headerlink&quot; title=&quot;项目源码&quot;&gt;&lt;/a&gt;项目源码&lt;/h2&gt;&lt;p&gt;项目源码托管在GitHub上，地址如下：&lt;strong&gt;&lt;a href=&quot;https://github.com/rssnsj/openwrt-hc5x61&quot;&gt;openwrt-hc5x61&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本项目使用的是&lt;a href=&quot;http://www.hiwifi.com/&quot;&gt;极路由&lt;/a&gt;的极路由2路由器。&lt;/p&gt;
&lt;h2 id=&quot;前提工作&quot;&gt;&lt;a href=&quot;#前提工作&quot; class=&quot;headerlink&quot; title=&quot;前提工作&quot;&gt;&lt;/a&gt;前提工作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;必装工具(仅限Debian和Ubuntu)&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install build-essential git subversion wget flex gettext libncurses5-dev unzip gawk liblzma-dev zlib1g-dev ccache u-boot-tools&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Checkout项目代码&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/rssnsj/openwrt-hc5x61.git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OpenWRT" scheme="http://whaoyu.com/categories/OpenWRT/"/>
    
    
      <category term="OpenWRT" scheme="http://whaoyu.com/tags/OpenWRT/"/>
    
      <category term="make" scheme="http://whaoyu.com/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO Selector解析</title>
    <link href="http://whaoyu.com/2017/01/09/java-nio-selector/"/>
    <id>http://whaoyu.com/2017/01/09/java-nio-selector/</id>
    <published>2017-01-09T10:41:57.000Z</published>
    <updated>2017-01-20T09:02:07.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Selector的主要方法有三个：</p>
<ul>
<li>Selector.open():Selector<br>主要用于创建一个selector</li>
<li>select():int<br>该方法有两种模式：在阻塞模式下，该方法会一直阻塞，直到超时或者有注册的事件发生，返回发生事件的数量；在非阻塞模式下，会立即返回，如果没有事件发生，则返回0。</li>
<li>selectedKeys():Set<selectionkey><br>获取已经就绪的事件的key的集合。</selectionkey></li>
</ul>
<h3 id="Selector-open-原理"><a href="#Selector-open-原理" class="headerlink" title="Selector.open()原理"></a>Selector.open()原理</h3><p>通过阅读<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/nio/channels/Selector.java?av=f" target="_blank" rel="external"><strong>java.nio.channels.Selector</strong></a>的源码（如下），可以发现，其调用了<code>SelectorProvider.provider()</code>的<code>openSelector()</code>函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Selector More ...open() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看<code>SelectorProvider.provider()</code>，在这个函数中，保证了provider有且仅有一个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)   <span class="comment">//保证只有一个</span></div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (loadProviderFromProperty())</div><div class="line">                        <span class="keyword">return</span> provider;</div><div class="line">                    <span class="keyword">if</span> (loadProviderAsService())</div><div class="line">                        <span class="keyword">return</span> provider;</div><div class="line">                    provider = sun.nio.ch.DefaultSelectorProvider.create();</div><div class="line">                    <span class="keyword">return</span> provider;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>再看<code>create()</code>函数，在该函数中，区分了操作系统，在Windows下，使用的是<code>sun.nio.ch.PollSelectorProvider</code>类，作为Selector。也就是说，<strong>SelectorProvider.provider()返回了一个PollSelectorProvider对象。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    String osname = AccessController</div><div class="line">        .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">"os.name"</span>));</div><div class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">"SunOS"</span>))</div><div class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.DevPollSelectorProvider"</span>);</div><div class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">"Linux"</span>))</div><div class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.EPollSelectorProvider"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/nio/ch/PollSelectorProvider.java" target="_blank" rel="external"><strong>sun.nio.ch.PollSelectorProvider</strong></a>的<code>openSelector()</code>函数（如下）中，返回了一个PollSelectorImpl的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PollSelectorProvider</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">SelectorProviderImpl</span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PollSelectorImpl(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">inheritedChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> InheritedChannel.getChannel();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在PollSelectorImpl的构造器（如下）中，我发现，其创建了一个pipe，创建函数是<code>IOUtil.makePipe()</code>，但是这个函数是native的，我估计应该是OS提供的一个函数。这个pipe的主要作用是，在select()函数被阻塞的时候，用于唤醒线程使用。</p>
<p>需要注意的是，虽然函数名称叫做makePipe，但是在Windows平台下实现中，并没有使用pipe，而是使用的TCP连接。</p>
<p>同时还要注意<code>super</code>函数的参数，第一个<strong>1</strong>是channels总数，第二个<strong>1</strong>是偏移量，说明，在初始化过程中，就已经有一个channel在这个数组中了，channels[0]就是刚刚创建的pipe。这个channel就是用来唤醒select()的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PollSelectorImpl(SelectorProvider sp) &#123;</div><div class="line">    <span class="keyword">super</span>(sp, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);  <span class="comment">//创建pipe</span></div><div class="line">    fd0 = (<span class="keyword">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</div><div class="line">    fd1 = (<span class="keyword">int</span>) pipeFds;</div><div class="line">    pollWrapper = <span class="keyword">new</span> PollArrayWrapper(INIT_CAP);</div><div class="line">    pollWrapper.initInterrupt(fd0, fd1);</div><div class="line">    channelArray = <span class="keyword">new</span> SelectionKeyImpl[INIT_CAP];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>综上所述，<code>Selector.open()</code>函数的作用是：<strong>保证了provider有且仅有一个，并返回了一个PollSelectorImpl对象，同时创建了一条pipe</strong>。</p>
<h3 id="select-原理"><a href="#select-原理" class="headerlink" title="select()原理"></a>select()原理</h3><p>select的执行体是在<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/nio/ch/PollSelectorImpl.java" target="_blank" rel="external"><strong><code>sun.nio.ch.PollSelectorImpl</code></strong></a>中的<code>doSelect</code>函数（如下）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (channelArray == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">    processDeregisterQueue();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        begin();</div><div class="line">        pollWrapper.poll(totalChannels, <span class="number">0</span>, timeout);    <span class="comment">//在这里轮询</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        end();</div><div class="line">    &#125;</div><div class="line">    processDeregisterQueue();</div><div class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</div><div class="line">    <span class="keyword">if</span> (pollWrapper.getReventOps(<span class="number">0</span>) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// Clear the wakeup pipe</span></div><div class="line">        pollWrapper.putReventOps(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">synchronized</span> (interruptLock) &#123;</div><div class="line">            IOUtil.drain(fd0);</div><div class="line">            interruptTriggered = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numKeysUpdated;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>updateSelectedKeys()</code>函数（如下）的实现是在<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/nio/ch/AbstractPollSelectorImpl.java" target="_blank" rel="external"><strong>sun.nio.ch.AbstractPollSelectorImpl</strong></a>中。<br>通过<code>getReventOps()</code>函数来判断通道是否有事件发生，若发生，将其加入到<code>selectedKeys</code>中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Copy the information in the pollfd structs into the opss</div><div class="line"> * of the corresponding Channels. Add the ready keys to the</div><div class="line"> * ready queue.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">updateSelectedKeys</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</div><div class="line">    <span class="comment">// Skip zeroth entry; it is for interrupts only</span></div><div class="line">    <span class="comment">// 第0个是自带的，用于唤醒select()的，因此从1开始循环。</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++) &#123;</div><div class="line">        <span class="keyword">int</span> rOps = pollWrapper.getReventOps(i);</div><div class="line">        <span class="keyword">if</span> (rOps != <span class="number">0</span>) &#123;</div><div class="line">            SelectionKeyImpl sk = channelArray[i];</div><div class="line">            pollWrapper.putReventOps(i, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (selectedKeys.contains(sk)) &#123;</div><div class="line">                <span class="keyword">if</span> (sk.channel.translateAndSetReadyOps(rOps, sk)) &#123;</div><div class="line">                    numKeysUpdated++;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sk.channel.translateAndSetReadyOps(rOps, sk);</div><div class="line">                <span class="keyword">if</span> ((sk.nioReadyOps() &amp; sk.nioInterestOps()) != <span class="number">0</span>) &#123;</div><div class="line">                    selectedKeys.add(sk);</div><div class="line">                    numKeysUpdated++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numKeysUpdated;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="selectedKeys-原理"><a href="#selectedKeys-原理" class="headerlink" title="selectedKeys()原理"></a>selectedKeys()原理</h3><p>该方法直接返回publicSelectedKeys这个Set。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isOpen() &amp;&amp; !Util.atBugLevel(<span class="string">"1.4"</span>))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">    <span class="keyword">return</span> publicSelectedKeys;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>publicSelectedKeys在<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/nio/ch/SelectorImpl.java" target="_blank" rel="external"><strong>SelectorImpl</strong></a>中的初始化中，与<code>selectedKeys</code>做了绑定，并在<code>updateSelectedKeys()</code>函数中，进行更新。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(sp);</div><div class="line">    keys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</div><div class="line">    selectedKeys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</div><div class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">"1.4"</span>)) &#123;</div><div class="line">        publicKeys = keys;</div><div class="line">        publicSelectedKeys = selectedKeys;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        publicKeys = Collections.unmodifiableSet(keys);</div><div class="line">        publicSelectedKeys = Util.ungrowableSet(selectedKeys);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="http://blog.csdn.net/u010412719/article/details/52760004" target="_blank" rel="external">Java NIO</a></li>
<li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="external">Java NIO 系列教程</a></li>
<li><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/" target="_blank" rel="external">Java源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;Selector的主要方法有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Selector.open():Selector&lt;br&gt;主要用于创建一个selector&lt;/li&gt;
&lt;li&gt;select():int&lt;br&gt;该方法有两种模式：在阻塞模式下，该方法会一直阻塞，直到超时或者有注册的事件发生，返回发生事件的数量；在非阻塞模式下，会立即返回，如果没有事件发生，则返回0。&lt;/li&gt;
&lt;li&gt;selectedKeys():Set&lt;SelectionKey&gt;&lt;br&gt;获取已经就绪的事件的key的集合。&lt;/SelectionKey&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Selector-open-原理&quot;&gt;&lt;a href=&quot;#Selector-open-原理&quot; class=&quot;headerlink&quot; title=&quot;Selector.open()原理&quot;&gt;&lt;/a&gt;Selector.open()原理&lt;/h3&gt;&lt;p&gt;通过阅读&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/nio/channels/Selector.java?av=f&quot;&gt;&lt;strong&gt;java.nio.channels.Selector&lt;/strong&gt;&lt;/a&gt;的源码（如下），可以发现，其调用了&lt;code&gt;SelectorProvider.provider()&lt;/code&gt;的&lt;code&gt;openSelector()&lt;/code&gt;函数。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Selector More ...open() &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; SelectorProvider.provider().openSelector();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;SelectorProvider.provider()&lt;/code&gt;，在这个函数中，保证了provider有且仅有一个。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; SelectorProvider &lt;span class=&quot;title&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (lock) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (provider != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;//保证只有一个&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; provider;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;SelectorProvider&amp;gt;() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; SelectorProvider &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (loadProviderFromProperty())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; provider;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (loadProviderAsService())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; provider;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    provider = sun.nio.ch.DefaultSelectorProvider.create();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; provider;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://whaoyu.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://whaoyu.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://whaoyu.com/tags/NIO/"/>
    
      <category term="Selector" scheme="http://whaoyu.com/tags/Selector/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO Buffer解析</title>
    <link href="http://whaoyu.com/2017/01/09/java-nio-buffer/"/>
    <id>http://whaoyu.com/2017/01/09/java-nio-buffer/</id>
    <published>2017-01-09T10:36:02.000Z</published>
    <updated>2017-01-20T09:02:07.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><ul>
<li><p>capacity<br>作为一个内存块，Buffer有一个固定的大小值，也叫<code>capacity</code>.你只能往里写capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空(通过读数据或者清除数据)才能继续写数据往里写数据。</p>
</li>
<li><p>position<br>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0。position最大可为capacity–1。当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
</li>
<li><p>limit<br>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据。</p>
</li>
<li><p>三者关系如下：</p>
</li>
</ul>
<p><img src="/2017/01/09/java-nio-buffer/1.png" alt=""></p>
<h3 id="Buffer构造器"><a href="#Buffer构造器" class="headerlink" title="Buffer构造器"></a>Buffer构造器</h3><p>尽管Buffer是一个抽象类，但是依然有自己的构造器。<br>其主要作用是初始化抽象类的成员和子类的初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// package-private</span></div><div class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative capacity: "</span> + cap);</div><div class="line">    <span class="keyword">this</span>.capacity = cap;</div><div class="line">    limit(lim);</div><div class="line">    position(pos);</div><div class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mark &gt; pos)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mark &gt; position: ("</span></div><div class="line">                                               + mark + <span class="string">" &gt; "</span> + pos + <span class="string">")"</span>);</div><div class="line">        <span class="keyword">this</span>.mark = mark;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Buffer常用方法"><a href="#Buffer常用方法" class="headerlink" title="Buffer常用方法"></a>Buffer常用方法</h3><ul>
<li>allocate()        分配一段空间的Buffer对象</li>
<li>put()             用于往Buffer中添加元素</li>
<li>flip()            用于将写模式转化为读模式</li>
<li>hasRemaining()    判断Buffer中是否还有元素可读</li>
<li>get()             读取Buffer中position位置的元素</li>
<li>clear()           清空Buffer </li>
<li>compact()         清除已读取的部分</li>
</ul>
<h3 id="关于Buffer的数据结构"><a href="#关于Buffer的数据结构" class="headerlink" title="关于Buffer的数据结构"></a>关于Buffer的数据结构</h3><p>通过查看<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/nio/IntBuffer.java?av=f" target="_blank" rel="external"><strong>java.nio.IntBuffer</strong></a>这个类的初始化函数及成员（如下），可以确定，<strong>Buffer的基本数据结构是数组！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</div><div class="line"><span class="keyword">boolean</span> isReadOnly;                 <span class="comment">// Valid only for heap buffers</span></div><div class="line"></div><div class="line"><span class="comment">// Creates a new buffer with the given mark, position, limit, capacity,</span></div><div class="line"><span class="comment">// backing array, and array offset</span></div><div class="line"><span class="comment">//</span></div><div class="line">IntBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// package-private</span></div><div class="line">          <span class="keyword">int</span>[] hb, <span class="keyword">int</span> offset)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</div><div class="line">    <span class="keyword">this</span>.hb = hb;</div><div class="line">    <span class="keyword">this</span>.offset = offset;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="关于compact函数的实现"><a href="#关于compact函数的实现" class="headerlink" title="关于compact函数的实现"></a>关于compact函数的实现</h3><p>这个函数我是比较感兴趣的，他与<code>clear()</code>的区别是只删除已读的部分。</p>
<p>通过查看<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/nio/HeapIntBuffer.java?av=f" target="_blank" rel="external"><strong>java.nio.HeapIntBuffer</strong></a>，该类是<strong>java.nio.IntBuffer</strong>的子类，可以得知compact函数的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 将剩余的没有访问的元素拷贝到Buffer从零开始的位置</span></div><div class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</div><div class="line">    <span class="comment">// 重置position</span></div><div class="line">    position(remaining());</div><div class="line">    <span class="comment">// 重置limit</span></div><div class="line">    limit(capacity());</div><div class="line">    <span class="comment">// 删除mark</span></div><div class="line">    discardMark();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="http://blog.csdn.net/u010412719/article/details/52760004" target="_blank" rel="external">Java NIO</a></li>
<li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="external">Java NIO 系列教程</a></li>
<li><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/" target="_blank" rel="external">Java源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要属性&quot;&gt;&lt;a href=&quot;#主要属性&quot; class=&quot;headerlink&quot; title=&quot;主要属性&quot;&gt;&lt;/a&gt;主要属性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;capacity&lt;br&gt;作为一个内存块，Buffer有一个固定的大小值，也叫&lt;code&gt;capacity&lt;/code&gt;.你只能往里写capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空(通过读数据或者清除数据)才能继续写数据往里写数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;position&lt;br&gt;当你写数据到Buffer中时，position表示当前的位置。初始的position值为0。position最大可为capacity–1。当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;limit&lt;br&gt;在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;三者关系如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2017/01/09/java-nio-buffer/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Buffer构造器&quot;&gt;&lt;a href=&quot;#Buffer构造器&quot; class=&quot;headerlink&quot; title=&quot;Buffer构造器&quot;&gt;&lt;/a&gt;Buffer构造器&lt;/h3&gt;&lt;p&gt;尽管Buffer是一个抽象类，但是依然有自己的构造器。&lt;br&gt;其主要作用是初始化抽象类的成员和子类的初始化。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Buffer(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mark, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pos, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; lim, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cap) &amp;#123;       &lt;span class=&quot;comment&quot;&gt;// package-private&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cap &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&quot;Negative capacity: &quot;&lt;/span&gt; + cap);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.capacity = cap;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    limit(lim);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    position(pos);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mark &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mark &amp;gt; pos)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&quot;mark &amp;gt; position: (&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                               + mark + &lt;span class=&quot;string&quot;&gt;&quot; &amp;gt; &quot;&lt;/span&gt; + pos + &lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mark = mark;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://whaoyu.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://whaoyu.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://whaoyu.com/tags/NIO/"/>
    
      <category term="Buffer" scheme="http://whaoyu.com/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket通讯</title>
    <link href="http://whaoyu.com/2017/01/04/java-socket/"/>
    <id>http://whaoyu.com/2017/01/04/java-socket/</id>
    <published>2017-01-04T01:44:12.000Z</published>
    <updated>2017-01-20T09:02:07.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-ServerSocket与Socket交互"><a href="#Java-ServerSocket与Socket交互" class="headerlink" title="Java ServerSocket与Socket交互"></a>Java ServerSocket与Socket交互</h2><p><img src="/2017/01/04/java-socket/1.png" alt=""></p>
<h2 id="ServerSocket与Socket的区别"><a href="#ServerSocket与Socket的区别" class="headerlink" title="ServerSocket与Socket的区别"></a>ServerSocket与Socket的区别</h2><h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>ServerSocket对象可以监听一个固定的端口，但不能主动发起连接。</p>
<ul>
<li>创建ServerSocket<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ServerSocket() <span class="keyword">throws</span> IOException;</div><div class="line">ServerSocket(<span class="keyword">int</span> port) <span class="keyword">throws</span> IOException;</div><div class="line">ServerSocket(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog) <span class="keyword">throws</span> IOException;</div><div class="line">ServerSocket(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr) <span class="keyword">throws</span> IOException;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过构造函数，可以确定<strong>监听端口(port)</strong>、<strong>客户端连接请求的队列长度(backlog)</strong>、<strong>服务端绑定IP(bindAddr)</strong>。</p>
<p>如果端口被占用或者没有权限使用某些端口会抛出BindException错误。譬如1~1023的端口需要管理员才拥有权限绑定。</p>
<p>如果设置端口为0，则系统会自动为其分配一个端口。</p>
<ul>
<li>监听端口<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket client = serverSocket.accept();</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>accept()</code>函数可以使Server端的程序处于<strong>等待状态</strong>，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象。此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时。</p>
<ul>
<li>关闭ServerSocket<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">serverSocket.close();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在关闭ServerSocket后，将释放其绑定的端口。</p>
<a id="more"></a>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>用于发起Socket连接，并且是通讯的数据通道。</p>
<ul>
<li>创建Socket<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Socket();</div><div class="line">Socket(InetAddress address, <span class="keyword">int</span> port) <span class="keyword">throws</span> UnknownHostException, IOException;</div><div class="line">Socket(InetAddress address, <span class="keyword">int</span> port, InetAddress localAddress, <span class="keyword">int</span> localPort)<span class="keyword">throws</span> IOException;</div><div class="line">Socket(String host, <span class="keyword">int</span> port)<span class="keyword">throws</span> UnknownHostException, IOException;</div><div class="line">Socket(String host, <span class="keyword">int</span> port, InetAddress localAddress, <span class="keyword">int</span> localPort)<span class="keyword">throws</span> IOException;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过构造函数可以确定<strong>目的主机IP(host)</strong>、<strong>目的主机端口(port)</strong>、<strong>本地IP(localAddress)</strong>、<strong>本地端口(localPort)</strong>。</p>
<ul>
<li><p>Socket常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getInetAddress();       <span class="comment">//远程服务端的IP地址</span></div><div class="line">getPort();              <span class="comment">//远程服务端的端口</span></div><div class="line">getLocalAddress();      <span class="comment">//本地客户端的IP地址</span></div><div class="line">getLocalPort();         <span class="comment">//本地客户端的端口</span></div><div class="line">getInputStream();       <span class="comment">//获得输入流</span></div><div class="line">getOutStream();         <span class="comment">//获得输出流</span></div></pre></td></tr></table></figure>
</li>
<li><p>Socket状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isClosed();     <span class="comment">//连接是否已关闭，若关闭，返回true；否则返回false</span></div><div class="line">isConnect();    <span class="comment">//如果曾经连接过，返回true；否则返回false</span></div><div class="line">isBound();      <span class="comment">//如果Socket已经与本地一个端口绑定，返回true；否则返回false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong>在发送和接收数据后，需要调用分别调用<code>shutdownOutput()</code>和<code>shutdownInput()</code>，告诉对方输入输出已经结束。</p>
<h2 id="服务端设计方法"><a href="#服务端设计方法" class="headerlink" title="服务端设计方法"></a>服务端设计方法</h2><p>服务器端设置通常有两种方式：单线程方式和多线程方式。在Web服务器中，多线程方式更常见。</p>
<p>多线程方式结构通常如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        Socket socket=<span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            socket=serverSocket.accept();                        <span class="comment">//主线程获取客户端连接</span></div><div class="line">            Thread workThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Handler(socket));    <span class="comment">//创建线程</span></div><div class="line">            workThread.start();                                    <span class="comment">//启动线程</span></div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在多线程的管理上，特别是实际生产环境中，通常使用线程池的方式来实现。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.cnblogs.com/rond/p/3565113.html" target="_blank" rel="external">[Java]Socket和ServerSocket学习笔记</a></li>
<li><a href="http://www.cnblogs.com/hq-antoine/archive/2012/02/11/2346474.html" target="_blank" rel="external">Java Socket 编程之Socket与ServerSocket的区别</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-ServerSocket与Socket交互&quot;&gt;&lt;a href=&quot;#Java-ServerSocket与Socket交互&quot; class=&quot;headerlink&quot; title=&quot;Java ServerSocket与Socket交互&quot;&gt;&lt;/a&gt;Java ServerSocket与Socket交互&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2017/01/04/java-socket/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ServerSocket与Socket的区别&quot;&gt;&lt;a href=&quot;#ServerSocket与Socket的区别&quot; class=&quot;headerlink&quot; title=&quot;ServerSocket与Socket的区别&quot;&gt;&lt;/a&gt;ServerSocket与Socket的区别&lt;/h2&gt;&lt;h3 id=&quot;ServerSocket&quot;&gt;&lt;a href=&quot;#ServerSocket&quot; class=&quot;headerlink&quot; title=&quot;ServerSocket&quot;&gt;&lt;/a&gt;ServerSocket&lt;/h3&gt;&lt;p&gt;ServerSocket对象可以监听一个固定的端口，但不能主动发起连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建ServerSocket&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ServerSocket() &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ServerSocket(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; port) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ServerSocket(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; port, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; backlog) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ServerSocket(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; port, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; backlog, InetAddress bindAddr) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过构造函数，可以确定&lt;strong&gt;监听端口(port)&lt;/strong&gt;、&lt;strong&gt;客户端连接请求的队列长度(backlog)&lt;/strong&gt;、&lt;strong&gt;服务端绑定IP(bindAddr)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果端口被占用或者没有权限使用某些端口会抛出BindException错误。譬如1~1023的端口需要管理员才拥有权限绑定。&lt;/p&gt;
&lt;p&gt;如果设置端口为0，则系统会自动为其分配一个端口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听端口&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Socket client = serverSocket.accept();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;accept()&lt;/code&gt;函数可以使Server端的程序处于&lt;strong&gt;等待状态&lt;/strong&gt;，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象。此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭ServerSocket&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;serverSocket.close();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在关闭ServerSocket后，将释放其绑定的端口。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://whaoyu.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://whaoyu.com/tags/Java/"/>
    
      <category term="Socket" scheme="http://whaoyu.com/tags/Socket/"/>
    
      <category term="ServerSocket" scheme="http://whaoyu.com/tags/ServerSocket/"/>
    
  </entry>
  
  <entry>
    <title>Android Service简介</title>
    <link href="http://whaoyu.com/2017/01/03/android-service/"/>
    <id>http://whaoyu.com/2017/01/03/android-service/</id>
    <published>2017-01-03T02:04:36.000Z</published>
    <updated>2017-01-20T09:02:06.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p>
<h2 id="服务形式："><a href="#服务形式：" class="headerlink" title="服务形式："></a>服务形式：</h2><ol>
<li><p>启动<br>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</p>
</li>
<li><p>绑定<br>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<a id="more"></a>
</li>
</ol>
<blockquote><p><strong>PS:</strong><br>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>
</blockquote>
<h2 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h2><ul>
<li><p>onStartCommand()<br>当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。）</p>
</li>
<li><p>onBind()<br>当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。</p>
</li>
<li><p>onCreate()<br>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。</p>
</li>
<li><p>onDestroy()<br>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。这是服务接收的最后一个调用。</p>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/2017/01/03/android-service/1.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.yiibai.com/android/android_services.html" target="_blank" rel="external">Android Service</a></li>
<li><a href="http://www.cnblogs.com/newcj/archive/2011/05/30/2061370.html" target="_blank" rel="external">Android 中的 Service 全面总结</a></li>
<li><a href="https://developer.android.com/guide/components/services.html" target="_blank" rel="external">Service | Android Developers</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。&lt;/p&gt;
&lt;h2 id=&quot;服务形式：&quot;&gt;&lt;a href=&quot;#服务形式：&quot; class=&quot;headerlink&quot; title=&quot;服务形式：&quot;&gt;&lt;/a&gt;服务形式：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动&lt;br&gt;当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绑定&lt;br&gt;当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://whaoyu.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://whaoyu.com/tags/Android/"/>
    
      <category term="Service" scheme="http://whaoyu.com/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>C++中的extern&quot;C&quot;{}</title>
    <link href="http://whaoyu.com/2016/10/13/extren-c/"/>
    <id>http://whaoyu.com/2016/10/13/extren-c/</id>
    <published>2016-10-13T13:10:25.000Z</published>
    <updated>2017-01-20T09:02:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在华为实习的时候，经常看见以下语句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//一段代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></div><div class="line">&#125; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>当时不理解这是什么意思，但是，有时候，某个函数不在这里面，在编译的时候会失败。</p>
<p>前几天问了以下<strong>邹建伟</strong>老师，得到了答案。</p>
<h2 id="老师的解释"><a href="#老师的解释" class="headerlink" title="老师的解释"></a>老师的解释</h2><p>extern “C”的主要作用就是提示C++编译器按C语言语义编译某些按C语言语义书写的函数代码，即加上extern “C”后，会指示C++编译器对“{}”内声明的函数，按C语言语义进行编译，而不是按C++语义进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。这样做的目的是如果一个程序主要按C++语义来编写，但是需要调用之前由C语言语义编写的函数代码（最可能的情况是要调用以前由C语言实现的函数库中的函数），就要使用这个语句。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是提示C++编译器，foo（）是一个在外部模块实现的函数，且是以C语言事先实现的（一般是指某个函数库中的函数），这样编译器就不需要在本模块中找foo的代码（不使用extern声明的话，编译器会报错），在linker链接时，结合头文件的声明，可以把foo函数在函数库中的代码链接到可执行文件映像中。</p>
<h2 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h2><p><code>extern &quot;C&quot; {}</code>的作用就是让编译器在编译这一块代码块时，使用<strong>C的编译器</strong>，而不是C++编译器。</p>
<a id="more"></a>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>转载自：<a href="http://blog.csdn.net/xl_lbj/article/details/12510309" target="_blank" rel="external">http://blog.csdn.net/xl_lbj/article/details/12510309</a></p>
<p>时常在cpp的代码之中看到这样的代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//一段代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></div><div class="line">&#125; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>这样的代码到底是什么意思呢？首先，<code>__cplusplus</code>是cpp中的自定义宏，那么定义了这个宏的话表示这是一段cpp的代码，也就是说，上面的代码的含义是:如果这是一段cpp的代码，那么加入extern “C”{和}处理其中的代码。</p>
<p>要明白为何使用<code>extern &quot;C&quot;</code>，还得从cpp中对函数的重载处理开始说起。</p>
<p>在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等。</p>
<p>而在C中，只是简单的函数名字而已，不会加入其他的信息。</p>
<p>也就是说:C++和C对产生的函数名字的处理是不一样的。</p>
<p>目的就是主要实现C与C++的相互调用问题。</p>
<p>c.h的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _c_h_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _c_h_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">C_fun</span><span class="params">()</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>c.c的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"c.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">C_fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在cpp.cpp中调用c.c中的<code>C_test()</code></p>
<p>cpp.cpp的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"c.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">     C_fun()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>__cplusplus</code>是C++编译器的保留宏定义．就是说C++编译器认为这个宏已经定义了。</p>
<p>所以关键是extern “C” {} </p>
<p>extern “C”是告诉C++编译器件括号里的东东(比如函数)是按照C的obj文件格式编译的，要连接的话按照C的命名规则去找．</p>
<p>那么C中是如何调用C++中的函数cpp_fun()呢？<br>因为先有C后有C++, 所以只能从C++的代码中考虑了．<br>加入C++中的函数或变量有可能被C中的文件调用，则应该这样写，也是用extern “C”{}<br>不过是代码中要加，头文件也要加，因为可能是C++中也调用</p>
<p>cpp.h的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _c_h_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _c_h_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPP_fun</span><span class="params">()</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>cpp.cpp的实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;    <span class="comment">//告诉C+++编译器,扩号里按照C的命名规则编译</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPP_fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">     .....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C和C++对函数的处理方式是不同的。<br>extern “C”是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern “C”来说明。</p>
<p>__cplusplus是C++编译器的保留宏定义<br>extern “C” {  …… }   //告诉C+++编译器,扩号里按照C的命名规则进行编译</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在华为实习的时候，经常看见以下语句：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; __cplusplus &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt; &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一段代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; __cplusplus &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当时不理解这是什么意思，但是，有时候，某个函数不在这里面，在编译的时候会失败。&lt;/p&gt;
&lt;p&gt;前几天问了以下&lt;strong&gt;邹建伟&lt;/strong&gt;老师，得到了答案。&lt;/p&gt;
&lt;h2 id=&quot;老师的解释&quot;&gt;&lt;a href=&quot;#老师的解释&quot; class=&quot;headerlink&quot; title=&quot;老师的解释&quot;&gt;&lt;/a&gt;老师的解释&lt;/h2&gt;&lt;p&gt;extern “C”的主要作用就是提示C++编译器按C语言语义编译某些按C语言语义书写的函数代码，即加上extern “C”后，会指示C++编译器对“{}”内声明的函数，按C语言语义进行编译，而不是按C++语义进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。这样做的目的是如果一个程序主要按C++语义来编写，但是需要调用之前由C语言语义编写的函数代码（最可能的情况是要调用以前由C语言实现的函数库中的函数），就要使用这个语句。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就是提示C++编译器，foo（）是一个在外部模块实现的函数，且是以C语言事先实现的（一般是指某个函数库中的函数），这样编译器就不需要在本模块中找foo的代码（不使用extern声明的话，编译器会报错），在linker链接时，结合头文件的声明，可以把foo函数在函数库中的代码链接到可执行文件映像中。&lt;/p&gt;
&lt;h2 id=&quot;综上所述&quot;&gt;&lt;a href=&quot;#综上所述&quot; class=&quot;headerlink&quot; title=&quot;综上所述&quot;&gt;&lt;/a&gt;综上所述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;extern &amp;quot;C&amp;quot; {}&lt;/code&gt;的作用就是让编译器在编译这一块代码块时，使用&lt;strong&gt;C的编译器&lt;/strong&gt;，而不是C++编译器。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://whaoyu.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://whaoyu.com/tags/C/"/>
    
      <category term="extern" scheme="http://whaoyu.com/tags/extern/"/>
    
      <category term="C" scheme="http://whaoyu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>EMAP模板中的坑</title>
    <link href="http://whaoyu.com/2016/09/23/emap-template-trap/"/>
    <id>http://whaoyu.com/2016/09/23/emap-template-trap/</id>
    <published>2016-09-23T13:21:28.000Z</published>
    <updated>2017-01-20T09:02:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习EMAP框架(一个比较小众的快速开发框架)，遇到了不少坑，同时，在交流群里，也总是看见不少同学在问这些问题。</p>
<p>这些问题其实不大，耐心调试也是可以解决了，但是会浪费好多时间，有不少同学会丧失学习的兴趣。</p>
<p>所以，我在这里汇总一下我自己学习过程中遇到的坑，希望对大家有帮助。</p>
<p>当然了，如果你自己遇到了什么坑，也可以告诉我，大家一起来完善 ^_^</p>
<h2 id="关于增、删、改、查"><a href="#关于增、删、改、查" class="headerlink" title="关于增、删、改、查"></a>关于增、删、改、查</h2><p>默认的模板，是只有列表功能的，其中的增删改查都是不能用的。主要表现在以下几点：</p>
<ul>
<li>控制台报错</li>
<li>显示保存成功，但是并没有增加数据</li>
<li>编辑只能编辑第一条数据的内容</li>
<li>详情只能查看第一条数据的内容</li>
<li>编辑、详情中的每一项数据的名字是<code>undefined</code></li>
<li>无法删除数据</li>
<li>……</li>
</ul>
<a id="more"></a>
<h3 id="关于undefined"><a href="#关于undefined" class="headerlink" title="关于undefined"></a>关于<code>undefined</code></h3><p>这个是由于你的<strong>数据模型</strong>或者<strong>业务模型中</strong>中忘记添加<strong>中文名称</strong>的原因。</p>
<h3 id="增——保存"><a href="#增——保存" class="headerlink" title="增——保存"></a>增——保存</h3><p>在<strong>xxxxBS.js</strong>中，将<code>save</code>方法中的<code>TODO</code>下方的注释去掉，同时，要将<code>doAjax</code>方法的<strong>第一个参数</strong>改成你自己的动作，一般为<code>XXX_SAVE.do</code></p>
<h3 id="删——删除"><a href="#删——删除" class="headerlink" title="删——删除"></a>删——删除</h3><p>在<strong>xxxxBS.js</strong>中，将<code>del</code>方法中的<code>TODO</code>下方的注释去掉，同时，要将<code>doAjax</code>方法的<strong>第一个参数</strong>改成你自己的动作，一般为<code>XXX_DELETE.do</code>，<br>还要将下面一行的开头也改为<code>XXX_DELETE</code>。</p>
<p>完成这一步，你应该可以看到删除成功的提示框了。</p>
<p>在<strong>xxxx.js</strong>中，将<code>actionDelete</code>方法中的<code>模型主键</code>一行的注释去掉，并且将<code>return</code>中的结果换成你自己表的主键。格式保持原样！</p>
<h3 id="改——编辑"><a href="#改——编辑" class="headerlink" title="改——编辑"></a>改——编辑</h3><p>在<strong>xxxx.js</strong>中，将<code>_initTable</code>方法中，将<code>编辑</code>前面的<code>rowData.WID</code>中的<strong>WID</strong>改成你自己的主键，或者可以查询的的标志。</p>
<p>这句话的作用就是在点击编辑，通过这个值在数据库表中进行索引。</p>
<p>在<strong>xxxx.js</strong>中，将<code>actionEdit</code>方法中，将下面这句话中的<code>WID:id</code>改成你自己的代码。看前面的代码，<strong>id</strong>就是你在<code>编辑</code>之前的那个<code>rowData.WID</code>，<strong>WID</strong>还是你的索引字段。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">WIS_EMAP_SERV</span>.getData(<span class="title">bs</span>.<span class="title">api</span>.<span class="title">pageModel</span>, '<span class="type">STUINFO_QUERY</span>', &#123;<span class="type">WID</span>:<span class="title">id</span>&#125;);</span></div></pre></td></tr></table></figure></p>
<h3 id="查——详情"><a href="#查——详情" class="headerlink" title="查——详情"></a>查——详情</h3><p>详情的修改应该是跟<strong>编辑</strong>差不多的。</p>
<p>在<strong>xxxx.js</strong>中，将<code>_initTable</code>方法中，将<code>详情</code>前面的<code>rowData.WID</code>中的<strong>WID</strong>改成你自己的主键，或者可以查询的的标志。</p>
<p>这句话的作用就是在点击详情，通过这个值在数据库表中进行索引。</p>
<p>在<strong>xxxx.js</strong>中，将<code>actionDetail</code>方法中，将下面这句话中的<code>WID:id</code>改成你自己的代码。看前面的代码，<strong>id</strong>就是你在<code>详情</code>之前的那个<code>rowData.WID</code>，<strong>WID</strong>还是你的索引字段。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">WIS_EMAP_SERV</span>.getData(<span class="title">bs</span>.<span class="title">api</span>.<span class="title">pageModel</span>, '<span class="type">STUINFO_QUERY</span>', &#123;<span class="type">WID</span>:<span class="title">id</span>&#125;);</span></div></pre></td></tr></table></figure></p>
<h2 id="快速搜索"><a href="#快速搜索" class="headerlink" title="快速搜索"></a>快速搜索</h2><p>有些同学会发现，自己跟着视频里操作，但是自己添加<strong>字典</strong>之后，该字段的显示方式还是下拉，并不是视频中的<strong>按钮组</strong>(视频中的性别的显示类型就叫这个名字)</p>
<p>其实可以在<strong>数据模型</strong>或者<strong>业务模型</strong>中，修改相关字段的<strong>查询显示属性</strong>中修改你的显示类型。</p>
<p>当然了，你也可以根据<strong>属性配置</strong>中的各种显示属性自己设置其他地方的显示类型。</p>
<h2 id="附件上传"><a href="#附件上传" class="headerlink" title="附件上传"></a>附件上传</h2><p>请参考我之前的文章：<a href="https://whaoyu.com/2016/09/21/emap-upload-file/">EMAP上传附件</a></p>
<h2 id="动作流保存失败"><a href="#动作流保存失败" class="headerlink" title="动作流保存失败"></a>动作流保存失败</h2><p>在视频中，老师说，动作流需要将表单的参数封装成一个json对象，key是动作流中动作的编号，value是你的表单数据。</p>
<p>错误信息如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The param KEY hasn't setted <span class="keyword">in</span> <span class="keyword">update</span> <span class="keyword">TABLE</span>.key.modify.</div></pre></td></tr></table></figure></p>
<p>其中，<strong>KEY</strong>和<strong>TABLE</strong>分别为表的主键和表名。</p>
<p>在这里，你应该将你的表单数据先转换成json字符串，然后才能作为value，封装进参数。具体如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">save: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        	<span class="keyword">if</span>( $(<span class="string">"#JBXX"</span>).emapValidate(<span class="string">'validate'</span>) </div><div class="line">        			&amp;&amp; $(<span class="string">"#LXXX"</span>).emapValidate(<span class="string">'validate'</span>) )&#123;</div><div class="line">        		<span class="keyword">var</span> formDataJBXX = <span class="built_in">JSON</span>.stringify($(<span class="string">"#JBXX"</span>).emapForm(<span class="string">"getValue"</span>));</div><div class="line">        		$(<span class="string">"#JBXX"</span>).emapForm(<span class="string">"saveUpload"</span>);</div><div class="line">        		<span class="keyword">var</span> formDataLXXX = <span class="built_in">JSON</span>.stringify($(<span class="string">"#LXXX"</span>).emapForm(<span class="string">"getValue"</span>));</div><div class="line">        		<span class="keyword">var</span> formData = &#123;</div><div class="line">        			<span class="attr">saveBasic</span> : formDataJBXX,</div><div class="line">        			<span class="attr">saveConn</span> : formDataLXXX</div><div class="line">        		&#125;;</div><div class="line">        		bs.save(formData).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    				alert(<span class="string">"保存成功"</span>);</div><div class="line">    				$(<span class="string">'#emapdatatable'</span>).emapdatatable(<span class="string">'reload'</span>);</div><div class="line">    				$.bhPaperPileDialog.hide();<span class="comment">//隐藏纸质弹窗</span></div><div class="line">    			&#125;);</div><div class="line">        	&#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p><strong>第四行</strong>和<strong>第六行</strong>中的<code>JSON.stringify</code>函数是加上的，而且老师没说的。</p>
<h2 id="EmapForm多图多文件上限"><a href="#EmapForm多图多文件上限" class="headerlink" title="EmapForm多图多文件上限"></a>EmapForm多图多文件上限</h2><p>在Emap Form初始化中添加参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">defaultOptions: &#123;</div><div class="line">	<span class="attr">uploadfile</span>: &#123;		<span class="comment">//多文件</span></div><div class="line">		limit： <span class="number">9</span></div><div class="line">	&#125;,</div><div class="line">	<span class="string">"uploadmuiltimage"</span>: &#123;	<span class="comment">//多图片</span></div><div class="line">		<span class="string">"limit"</span>: <span class="number">9</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>缺陷：当表单中有多个多文件/多图片时，不能单独设置。</p>
<h2 id="调整纸质弹窗的页脚位置"><a href="#调整纸质弹窗的页脚位置" class="headerlink" title="调整纸质弹窗的页脚位置"></a>调整纸质弹窗的页脚位置</h2><p>在使用纸质弹窗的时候，经常会出现页脚悬浮的情况，图下图：</p>
<p><img src="/2016/09/23/emap-template-trap/1.png" alt=""></p>
<p>调整方式是，在ready回掉函数中，添加以下代码：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$.</span>bhPaperPileDialog.resetPageFooter();<span class="regexp">//</span>改变页面的页脚位置</div><div class="line"><span class="variable">$.</span>bhPaperPileDialog.resetDialogFooter();<span class="regexp">//</span>改变弹框的页脚位置</div></pre></td></tr></table></figure></p>
<p>具体方式如下：</p>
<p><img src="/2016/09/23/emap-template-trap/2.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前我发现的坑，暂时有这些，这篇文章我会不定期的更新，欢迎大家来讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习EMAP框架(一个比较小众的快速开发框架)，遇到了不少坑，同时，在交流群里，也总是看见不少同学在问这些问题。&lt;/p&gt;
&lt;p&gt;这些问题其实不大，耐心调试也是可以解决了，但是会浪费好多时间，有不少同学会丧失学习的兴趣。&lt;/p&gt;
&lt;p&gt;所以，我在这里汇总一下我自己学习过程中遇到的坑，希望对大家有帮助。&lt;/p&gt;
&lt;p&gt;当然了，如果你自己遇到了什么坑，也可以告诉我，大家一起来完善 ^_^&lt;/p&gt;
&lt;h2 id=&quot;关于增、删、改、查&quot;&gt;&lt;a href=&quot;#关于增、删、改、查&quot; class=&quot;headerlink&quot; title=&quot;关于增、删、改、查&quot;&gt;&lt;/a&gt;关于增、删、改、查&lt;/h2&gt;&lt;p&gt;默认的模板，是只有列表功能的，其中的增删改查都是不能用的。主要表现在以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制台报错&lt;/li&gt;
&lt;li&gt;显示保存成功，但是并没有增加数据&lt;/li&gt;
&lt;li&gt;编辑只能编辑第一条数据的内容&lt;/li&gt;
&lt;li&gt;详情只能查看第一条数据的内容&lt;/li&gt;
&lt;li&gt;编辑、详情中的每一项数据的名字是&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;无法删除数据&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="EMAP" scheme="http://whaoyu.com/categories/EMAP/"/>
    
    
      <category term="EMAP" scheme="http://whaoyu.com/tags/EMAP/"/>
    
      <category term="模板" scheme="http://whaoyu.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="坑" scheme="http://whaoyu.com/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>EMAP上传附件</title>
    <link href="http://whaoyu.com/2016/09/21/emap-upload-file/"/>
    <id>http://whaoyu.com/2016/09/21/emap-upload-file/</id>
    <published>2016-09-21T15:42:18.000Z</published>
    <updated>2017-01-20T09:02:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>EMAP上传附件，需要在<strong>表单</strong>和<strong>显示页面</strong>中添加<code>contextPath</code>信息，同时，在获取到表单数据后，需要<strong>保存附件</strong>。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>具体操作如下：</p>
<ol>
<li>在<strong>表单</strong>中添加<code>contextPath</code>信息，文件<code>XXXXSave.js</code><br><img src="/2016/09/21/emap-upload-file/1.png" alt=""></li>
<li>获取表单数据后，保存表单中的附件，文件<code>XXXXSave.js</code><br><img src="/2016/09/21/emap-upload-file/2.png" alt=""></li>
<li>在<strong>显示页面</strong>中添加<code>contextPath</code>信息，文件<code>XXXXView.js</code><br><img src="/2016/09/21/emap-upload-file/3.png" alt=""></li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注1：以上操作，均是找到<em>蓝色</em>框中的代码，添加<strong>红色</strong>框中的代码。<br>注2：XXXXSave.js和XXXXView.js中的XXXX代表页面模型中的文件名。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;EMAP上传附件，需要在&lt;strong&gt;表单&lt;/strong&gt;和&lt;strong&gt;显示页面&lt;/strong&gt;中添加&lt;code&gt;contextP
    
    </summary>
    
      <category term="EMAP" scheme="http://whaoyu.com/categories/EMAP/"/>
    
    
      <category term="EMAP" scheme="http://whaoyu.com/tags/EMAP/"/>
    
  </entry>
  
  <entry>
    <title>软件实习报告</title>
    <link href="http://whaoyu.com/2016/09/17/software-practice/"/>
    <id>http://whaoyu.com/2016/09/17/software-practice/</id>
    <published>2016-09-17T10:16:11.000Z</published>
    <updated>2017-01-20T09:02:07.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>生产实习软件部分目的是锻炼学生从事开发计算机应用系统的能力和协同工作的能力。<br>使学生初步掌握以SQL Server数据库系统为核心，采用C/S结构的计算机应用系统开发方法（用Delphi语言开发），<br>使学生得到如何进行系统开发的初步锻炼。</p>
<p><strong>PS:</strong><br>其实，我们并没有使用SQL Server(MySQL)，C/S(B/S)结构和Delphi(Python) ^_^<br>主要是Delphi太过时了。<br>MySQL是因为有现成的云数据库，就不想搭建了。<br>B/S是因为html比较熟悉，而且Python写客户端，实在是很难看。</p>
<h2 id="系统结构设计"><a href="#系统结构设计" class="headerlink" title="系统结构设计"></a>系统结构设计</h2><p>整个系统包括四部分，分别是数据库服务器、WEB服务器、传输机和前置机。</p>
<p><img src="/2016/09/17/software-practice/1.jpg" alt=""></p>
<h3 id="连接与数据传输"><a href="#连接与数据传输" class="headerlink" title="连接与数据传输"></a>连接与数据传输</h3><p>数据库、WEB服务器与传输机之间使用网线连接，传输机与前置机之间使用串口线连接。</p>
<p>数据库与WEB服务器之间，使用MySQL的3306端口通讯，通过在数据库中添加远程受限用户，来访问数据库。</p>
<p>WEB服务器与前置机之间，使用HTTP协议传输数据，用户数据通过JSON封装。</p>
<p>前置机与传输机之间，用JSON封装数据，以换行符(<code>&#39;\n&#39;</code>)为结束标志。</p>
<h3 id="刷卡流程"><a href="#刷卡流程" class="headerlink" title="刷卡流程"></a>刷卡流程</h3><ol>
<li>前置机获取卡号信息，并以字符串的方式发送到传输机。</li>
<li>传输机将卡号以POST方式，发送到WEB服务器。</li>
<li>WEB服务器通过卡号，从数据库获取相关信息。</li>
<li>WEB服务器将卡片信息封装程JSON格式，并返回给传输机。</li>
<li>传输机将信息通过串口发送给前置机。</li>
<li>前置机解封数据，并最终显示。</li>
</ol>
<a id="more"></a>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root</div><div class="line"><span class="string">|</span></div><div class="line">+-Server	<span class="meta"># WEB服务器代码</span></div><div class="line"><span class="string">|</span></div><div class="line">+-transfer	<span class="meta"># 传输机代码</span></div><div class="line"><span class="string">|</span></div><div class="line">+-front		<span class="meta"># 前置机代码</span></div><div class="line"><span class="string">|</span></div><div class="line">+-database	<span class="meta"># 数据库创建脚本</span></div></pre></td></tr></table></figure>
<h2 id="各功能模块设计"><a href="#各功能模块设计" class="headerlink" title="各功能模块设计"></a>各功能模块设计</h2><h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><p>服务器端使用的是Flask框架，目录结构如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">|<span class="string"></span></div><div class="line">+-app</div><div class="line">|<span class="string"> </span>|</div><div class="line">|<span class="string"> +-module	# 数据模型</span></div><div class="line">|<span class="string"> </span>|</div><div class="line">|<span class="string"> +-templates	# 页面模板文件</span></div><div class="line">|<span class="string"> </span>|</div><div class="line">|<span class="string"> +-views.py	# 路由逻辑</span></div><div class="line">|<span class="string"> </span>|</div><div class="line">|<span class="string"> +-__init__.py	# 模块初始化</span></div><div class="line">|</div><div class="line">+-manage.py</div></pre></td></tr></table></figure></p>
<p>数据库通过flask-sqlalchemy将数据库抽象出来，并且实现数据库表与module之间的自由转换，<br>从而将WEB处理与数据库分离，可以适应各种不同的数据库，如：SQL Server、SQLite等。</p>
<p>通过CSRF实现防御<code>跨站请求伪造攻击(Cross-Site Request Forgery)</code>，<br>其原理是在表单中插入一个随机的<code>input</code>值，并在表单提交后，对其进行验证。从而防止跨站请求伪造攻击。</p>
<p>预约界面：<br><img src="/2016/09/17/software-practice/9.png" alt=""></p>
<p>管理界面：<br><img src="/2016/09/17/software-practice/10.png" alt=""></p>
<h3 id="传输机"><a href="#传输机" class="headerlink" title="传输机"></a>传输机</h3><p>传输机作为一个简单的传输模块，需要负责将前置机获取的学号通过POST请求发送到服务器，<br>同时在界面显示接收日志，以及是否传输成功。</p>
<p>传输机还要将服务器返回的内容通过串口发送给前置机，并在界面显示发送日志，以及是否传输成功。</p>
<p>作为传输机，需要有专门的一个线程负责监听串口的活动。由于Python的线程模块没有专门的停止方法，<br>只能等待线程自己停止。因此，我设置了一个<code>isStop</code>的变量，作为监听线程是否停止的标志。</p>
<p>由于这个变量被两个线程使用，因此，需要进行一些PV操作。通过Python中的<code>threading.Lock()</code>方法，<br>可以创建一个信号量，用来控制<code>isStop</code>变量的访问。从而解决资源冲突。</p>
<p>传输机界面：<br><img src="/2016/09/17/software-practice/7.png" alt=""></p>
<h3 id="前置机"><a href="#前置机" class="headerlink" title="前置机"></a>前置机</h3><p>前置机作为，主要任务是负责获取卡号，并显示必要的信息。因此需要GUI，本次实验使用的GUI模块为Python自带的Tkinter，<br>作为内置模块，操作相对简单，上手比较容易，适合新手学习使用，但是由于没有可视化操作，所以只能用代码实现简单的界面。</p>
<p>本次主要使用的GUI组件为<code>Label</code>和<code>Button</code>。<code>Label</code>负责在界面显示内容，<code>Button</code>负责与用户交互。</p>
<p>同样，如果需要更为美观的界面，可以使用<code>wxPython</code>等第三方GUI库。</p>
<p>由于串口的通讯是由前置机主动发起的，因此，前置机不需要单独的线程去监听串口，只需要在发送之后，立刻转入监听模式，<br>当收到信息后或者超时后，结束监听，回到待刷卡状态。</p>
<p>当然，为了保证通讯的质量，我们还可以在前置机与传输机、传输机与服务器之间，每隔一段时间，发送特定的报文，<br>用于验证是否处于联机状态，以确保通讯质量。</p>
<p>如果实验用于生产环境是，还需要对信息进行加密和校验，此处为实验环境，此功能不做考虑。</p>
<p>前置机界面：<br><img src="/2016/09/17/software-practice/8.png" alt=""></p>
<h2 id="数据库表结构设计及功能说明"><a href="#数据库表结构设计及功能说明" class="headerlink" title="数据库表结构设计及功能说明"></a>数据库表结构设计及功能说明</h2><h3 id="数据库类型及版本"><a href="#数据库类型及版本" class="headerlink" title="数据库类型及版本"></a>数据库类型及版本</h3><p>本次数据库是部署在阿里云上的MySQL，数据库版本为5.7。</p>
<p>使用这个数据库的原因是，我在阿里云上一直由一个可用的数据库，延时在20ms之内，速度较快，因此，不想在自己的PC上再安装。</p>
<p>由于本次实验是与学生相关，因此最好需要一个完整的学生信息数据库。<br>因此本次实验只是挑选了一部分与本实验相关的数据，进行了存储，因此，学生信息只有一张表。</p>
<h3 id="Admin表"><a href="#Admin表" class="headerlink" title="Admin表"></a>Admin表</h3><p>该表格为后台管理员表格，主要存放管理员的账号及密码。</p>
<p>在实际生产过程中，密码应密文保存，但在本次试验中，便于调试，使用的明文保存。</p>
<p>表结构如下：</p>
<p><img src="/2016/09/17/software-practice/2.png" alt=""></p>
<h3 id="Computer表"><a href="#Computer表" class="headerlink" title="Computer表"></a>Computer表</h3><p>该表为设备表，用来存放当前学校中，受该系统管理的所有设备信息。</p>
<p>表结构如下：</p>
<p><img src="/2016/09/17/software-practice/3.png" alt=""></p>
<h3 id="Log表"><a href="#Log表" class="headerlink" title="Log表"></a>Log表</h3><p>该表为日志表，主要用于存放所有用户的操作信息，对于删除和修改信息应当更加详细。</p>
<p>该表格可以在管理员误删信或者修改信息后，用于信息重建。</p>
<p>表结构如下：</p>
<p><img src="/2016/09/17/software-practice/4.png" alt=""></p>
<h3 id="Reservation表"><a href="#Reservation表" class="headerlink" title="Reservation表"></a>Reservation表</h3><p>该表为预约信息表，主要用来存放学生预约信息。</p>
<p>表结构如下：</p>
<p><img src="/2016/09/17/software-practice/5.png" alt=""></p>
<h3 id="StuInfo表"><a href="#StuInfo表" class="headerlink" title="StuInfo表"></a>StuInfo表</h3><p>该表为学生信息表，主要用来存放学生信息。该表应该与学生信息管理系统相关联，以提供完整的学生信息。</p>
<p>表结构如下：</p>
<p><img src="/2016/09/17/software-practice/6.png" alt=""></p>
<h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><h3 id="王浩宇"><a href="#王浩宇" class="headerlink" title="王浩宇"></a>王浩宇</h3><p>在本次试验中，我作为项目负责人，使用自顶向下的方法，设计了整个系统，虽然整个系统的扩展性并不好，稳定性也可能存在不少问题，但是，这次实验让我对软件设计有了更深入的了解。主动尝试了软件工程中的<code>桩</code>，将本应该只能在机房编写代码，通过增加桩，可以使不需要串口功能的模块在宿舍也可以编写，提高了工作效率。</p>
<p>这次实验使用Git最为代码的版本管理，可以方便的进行多人合作变成，每个人创建自己的开发分支，完成既定功能后，合入master分支中，不会出现一个人写代码，4个人旁边看着的情况。每个人都可以在自己的电脑上完成自己的工作，然后push到云上，这也是未来工作的模式。</p>
<p>这次实验中又一次使用了轻量级的Python Web框架——flask。并且又在这个基础上，增加了一下之前没有用过的功能，加深了对flask的理解。同时，在网上查找了关于web框架的资料，了解了web框架的基本原理。</p>
<h3 id="余一帆"><a href="#余一帆" class="headerlink" title="余一帆"></a>余一帆</h3><p>这次这个学生管理及上机及考勤系统的实验，加深了几台PC机是怎样协同工作是什么原理的理解。平常上课都是单独学习网页设计、数据库等，现在一下子完成一个简单的系统的操作，让我对整个过程的理解更加深入。</p>
<p>我们这次比较特殊的是我们用了python,而且为了共享代码还用了码云，这些对我来说都是比较陌生的东西。刚开始的时候为了把代码push到码云就花了不少时间，其他的我主要写前段这些，通过上网查资料和问组员倒是还好。</p>
<p>在这个实验中，不仅培养了独立思考、动手操作的能力，在各种其它能力上也都有了提高。更重要的是，在此次实验课中，我们把抽象的书本上的知识变成自己的。而这是日后最实用的，真的是受益匪浅。但是学习无止境，我们得不断的学习、实践，再学习、再实践。</p>
<h3 id="朱依凡"><a href="#朱依凡" class="headerlink" title="朱依凡"></a>朱依凡</h3><p>这次软件课程设计我和何颖婕一起跟着王浩宇设计前端部分，这次软件课设接触了新的语言python，我们花了一点时间来学习这个新的语言，我主要负责利用gui库tkinter来布置前端界面，刚开始以为会很困难，但是看了教程和请教了同学之后发现并没有想象中的困难，一步步都逐渐解决了问题，同时这次还接触到了git，熟悉了git的基本操作，刚开始学习git的时候觉得操作步骤很繁琐，但是到后来就发现它的基本操作并不多，熟悉了之后就非常方便，为我们提供了很大的便利。这次课设我感觉学到了很多新的知识，接触了新的语言python，新的版本控制系统github，我受益匪浅。</p>
<h3 id="左智文"><a href="#左智文" class="headerlink" title="左智文"></a>左智文</h3><p>通过这次的生产实习串口通讯部分的实践，不仅学会了使用git进行多人协作项目，而且应用了python 的一个轻量级的web框架flask，熟练了对于web前端的使用，感觉受益匪浅。</p>
<h3 id="何颖婕"><a href="#何颖婕" class="headerlink" title="何颖婕"></a>何颖婕</h3><p>在本次试验中，我主要是负责端页面的设计和编码，在组长的指导下完成实验的这个过程。在实验的过程中有很多困难，但在组员的团结合作下，以及上网或者在图书馆查阅资料都一一的克服了。看到自己的心血能运转起来，真的很开心，也通过这次实验学到了很多东西。在系统的设计上，大家一起思考，虽然整个系统的扩展性有待加强，功能也不是特别全面，但通过这次实验让我们对软件设计有了更深入的了解。</p>
<p>在实验的过程中，因为是团队写代码，实验使用Git代码管理的软件，让每个人的工作内容更加的明确，也使代码的编写更加的方便。在实验中，我们的代码的主要语言是Python, Python是一种简约语言，开发快，语言简洁。因为是一个相对而言，不那么复杂的系统，所以Python还是为我们提供了极大的便利。在这次实验中，使用了之前没有接触的Git和Python，对这些语言又有了新的了解。作为一个计算机专业的学生我觉得接触新的语言是很有必要的，会让我们从不同的角度去思考问题，比较各种语言的优缺点。通过这次实验，也让我体会到了，团队合作编写系统是一个怎样的过程，大家齐心协力为一个目标而努力的感觉真的很棒。希望自己将来走上工作岗位的时候，能继续享受工作带给我的成就感。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>项目代码：<a href="http://git.oschina.net/873314461/SchoolNet" target="_blank" rel="external">http://git.oschina.net/873314461/SchoolNet</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h2&gt;&lt;p&gt;生产实习软件部分目的是锻炼学生从事开发计算机应用系统的能力和协同工作的能力。&lt;br&gt;使学生初步掌握以SQL Server数据库系统为核心，采用C/S结构的计算机应用系统开发方法（用Delphi语言开发），&lt;br&gt;使学生得到如何进行系统开发的初步锻炼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS:&lt;/strong&gt;&lt;br&gt;其实，我们并没有使用SQL Server(MySQL)，C/S(B/S)结构和Delphi(Python) ^_^&lt;br&gt;主要是Delphi太过时了。&lt;br&gt;MySQL是因为有现成的云数据库，就不想搭建了。&lt;br&gt;B/S是因为html比较熟悉，而且Python写客户端，实在是很难看。&lt;/p&gt;
&lt;h2 id=&quot;系统结构设计&quot;&gt;&lt;a href=&quot;#系统结构设计&quot; class=&quot;headerlink&quot; title=&quot;系统结构设计&quot;&gt;&lt;/a&gt;系统结构设计&lt;/h2&gt;&lt;p&gt;整个系统包括四部分，分别是数据库服务器、WEB服务器、传输机和前置机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/09/17/software-practice/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;连接与数据传输&quot;&gt;&lt;a href=&quot;#连接与数据传输&quot; class=&quot;headerlink&quot; title=&quot;连接与数据传输&quot;&gt;&lt;/a&gt;连接与数据传输&lt;/h3&gt;&lt;p&gt;数据库、WEB服务器与传输机之间使用网线连接，传输机与前置机之间使用串口线连接。&lt;/p&gt;
&lt;p&gt;数据库与WEB服务器之间，使用MySQL的3306端口通讯，通过在数据库中添加远程受限用户，来访问数据库。&lt;/p&gt;
&lt;p&gt;WEB服务器与前置机之间，使用HTTP协议传输数据，用户数据通过JSON封装。&lt;/p&gt;
&lt;p&gt;前置机与传输机之间，用JSON封装数据，以换行符(&lt;code&gt;&amp;#39;\n&amp;#39;&lt;/code&gt;)为结束标志。&lt;/p&gt;
&lt;h3 id=&quot;刷卡流程&quot;&gt;&lt;a href=&quot;#刷卡流程&quot; class=&quot;headerlink&quot; title=&quot;刷卡流程&quot;&gt;&lt;/a&gt;刷卡流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;前置机获取卡号信息，并以字符串的方式发送到传输机。&lt;/li&gt;
&lt;li&gt;传输机将卡号以POST方式，发送到WEB服务器。&lt;/li&gt;
&lt;li&gt;WEB服务器通过卡号，从数据库获取相关信息。&lt;/li&gt;
&lt;li&gt;WEB服务器将卡片信息封装程JSON格式，并返回给传输机。&lt;/li&gt;
&lt;li&gt;传输机将信息通过串口发送给前置机。&lt;/li&gt;
&lt;li&gt;前置机解封数据，并最终显示。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="课程设计" scheme="http://whaoyu.com/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="串口" scheme="http://whaoyu.com/tags/%E4%B8%B2%E5%8F%A3/"/>
    
      <category term="flask" scheme="http://whaoyu.com/tags/flask/"/>
    
      <category term="Python" scheme="http://whaoyu.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>科研训练 研究内容</title>
    <link href="http://whaoyu.com/2016/09/04/SRTP-research-contents/"/>
    <id>http://whaoyu.com/2016/09/04/SRTP-research-contents/</id>
    <published>2016-09-04T09:56:22.000Z</published>
    <updated>2017-01-20T09:02:06.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上位机和下位机通讯"><a href="#上位机和下位机通讯" class="headerlink" title="上位机和下位机通讯"></a>上位机和下位机通讯</h1><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><p>串行异步通讯</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>串行异步通讯(Asynchronous Data Communication)以字符为单位进行传输，其协议是起止式异步通讯协议，传输字符格式如下图:<br><img src="/2016/09/04/SRTP-research-contents/ADC.png" alt=""></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="上位机"><a href="#上位机" class="headerlink" title="上位机"></a>上位机</h3><p>通过调用Linux系统的<code>/dev/ttyUSB0</code>文件，实现对串口的读写操作。</p>
<ol>
<li>设置串口属性<ul>
<li>波特率 115200</li>
<li>无奇偶校验</li>
<li>一个停止位</li>
</ul>
</li>
<li>将需要发送的数据转换成二进制字符串。包括两个字节，一个为距离，另一个为角度，均用用<code>-128~127</code>表示。</li>
<li>将转化完成的字符串，通过串口的<code>write</code>方法，写入串口。</li>
</ol>
<h3 id="下位机"><a href="#下位机" class="headerlink" title="下位机"></a>下位机</h3><p>启动一个线程，不断监听串口活动。<br>当串口监听到起始符号时，通过接收移位寄存器接收串口信息，当接收信息达到1个字节时，将触发串口接收寄存器满事件。<br>程序对串口接收到的数据进行处理，获取上位机传输的距离和角度信息，并根据信息进行相应的调整机器人的运动姿态。<br>当串口监听到停止位时，停止接收串口信息，结束本次传输。</p>
<a id="more"></a>
<h1 id="视频传输"><a href="#视频传输" class="headerlink" title="视频传输"></a>视频传输</h1><h2 id="方案一-自己实现视频传输模块"><a href="#方案一-自己实现视频传输模块" class="headerlink" title="方案一: 自己实现视频传输模块"></a>方案一: 自己实现视频传输模块</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过程序调用摄像头，每隔一段时间(为保证画面的连续性，应保证每秒获取24副图像)，获取当前摄像头的画面，并将数据转换成二进制字符串，通过TCP的Stream方式，将图片发送出去。<br>服务器端不断监听某个端口，当收socket时，将二进制字符串还原成图片，并显示出来。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>方案简单，容易实现。</li>
<li>可以得到摄像头的原图画质。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要较大的带宽，当摄像头分辨率较大时，对带宽的要求极高。</li>
<li>由于TCP连接需要IP地址，因此，在没有动态域名解析的情况下，只能适用于局域网。</li>
<li>容错性较差，容易出现不确定的错误，导致视频传输失败。</li>
<li>暂时只支持一对一传输。</li>
</ul>
<h2 id="方案二-使用RTMP协议"><a href="#方案二-使用RTMP协议" class="headerlink" title="方案二:使用RTMP协议"></a>方案二:使用RTMP协议</h2><h3 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h3><p>RTMP(Real Time Messaging Protocol)是一种设计用来进行实时数据通信的网络协议，<br>主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。<br>支持该协议的软件包括Adobe Media Server/Ultrant Media Server/red5等。</p>
<p>RTMP是目前直播平台主要的视频传输协议。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>在Linux环境下，通过使用FFmpeg获取摄像头图像，然后将图像转码，直接推向rtmp服务器。<br>具体命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ffmpeg -re -i ./test.flv -vcodec copy -acodec copy -f flv -y rtmp://cuplayer:1935/live2/livestream</div></pre></td></tr></table></figure></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>使用rtmp协议，可以支持多种视频格式，可以对视频进行压缩，因此只需要较低的网络带宽</li>
<li>容错性好，支持掉线重连。</li>
<li>支持一对一传输和一对多传输。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>进行一对多传输时，需要RTMP服务器。</li>
<li>在公网传输时，需要一台有公网IP或域名的RTMP服务器。</li>
</ul>
<h2 id="方案三-使用现成的网络摄像头"><a href="#方案三-使用现成的网络摄像头" class="headerlink" title="方案三:使用现成的网络摄像头"></a>方案三:使用现成的网络摄像头</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>学习成本低，使用方便。</li>
<li>可以在公网传输视频。</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>成本较高</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;上位机和下位机通讯&quot;&gt;&lt;a href=&quot;#上位机和下位机通讯&quot; class=&quot;headerlink&quot; title=&quot;上位机和下位机通讯&quot;&gt;&lt;/a&gt;上位机和下位机通讯&lt;/h1&gt;&lt;h2 id=&quot;通讯方式&quot;&gt;&lt;a href=&quot;#通讯方式&quot; class=&quot;headerlink&quot; title=&quot;通讯方式&quot;&gt;&lt;/a&gt;通讯方式&lt;/h2&gt;&lt;p&gt;串行异步通讯&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;串行异步通讯(Asynchronous Data Communication)以字符为单位进行传输，其协议是起止式异步通讯协议，传输字符格式如下图:&lt;br&gt;&lt;img src=&quot;/2016/09/04/SRTP-research-contents/ADC.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h2&gt;&lt;h3 id=&quot;上位机&quot;&gt;&lt;a href=&quot;#上位机&quot; class=&quot;headerlink&quot; title=&quot;上位机&quot;&gt;&lt;/a&gt;上位机&lt;/h3&gt;&lt;p&gt;通过调用Linux系统的&lt;code&gt;/dev/ttyUSB0&lt;/code&gt;文件，实现对串口的读写操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置串口属性&lt;ul&gt;
&lt;li&gt;波特率 115200&lt;/li&gt;
&lt;li&gt;无奇偶校验&lt;/li&gt;
&lt;li&gt;一个停止位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将需要发送的数据转换成二进制字符串。包括两个字节，一个为距离，另一个为角度，均用用&lt;code&gt;-128~127&lt;/code&gt;表示。&lt;/li&gt;
&lt;li&gt;将转化完成的字符串，通过串口的&lt;code&gt;write&lt;/code&gt;方法，写入串口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;下位机&quot;&gt;&lt;a href=&quot;#下位机&quot; class=&quot;headerlink&quot; title=&quot;下位机&quot;&gt;&lt;/a&gt;下位机&lt;/h3&gt;&lt;p&gt;启动一个线程，不断监听串口活动。&lt;br&gt;当串口监听到起始符号时，通过接收移位寄存器接收串口信息，当接收信息达到1个字节时，将触发串口接收寄存器满事件。&lt;br&gt;程序对串口接收到的数据进行处理，获取上位机传输的距离和角度信息，并根据信息进行相应的调整机器人的运动姿态。&lt;br&gt;当串口监听到停止位时，停止接收串口信息，结束本次传输。&lt;/p&gt;
    
    </summary>
    
      <category term="课程设计" scheme="http://whaoyu.com/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="科研训练" scheme="http://whaoyu.com/tags/%E7%A7%91%E7%A0%94%E8%AE%AD%E7%BB%83/"/>
    
      <category term="串口" scheme="http://whaoyu.com/tags/%E4%B8%B2%E5%8F%A3/"/>
    
      <category term="视频传输" scheme="http://whaoyu.com/tags/%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93/"/>
    
      <category term="rtmp" scheme="http://whaoyu.com/tags/rtmp/"/>
    
  </entry>
  
  <entry>
    <title>帝都夏令营之旅</title>
    <link href="http://whaoyu.com/2016/07/24/ZhongkeyuanXialingying/"/>
    <id>http://whaoyu.com/2016/07/24/ZhongkeyuanXialingying/</id>
    <published>2016-07-24T12:44:05.000Z</published>
    <updated>2017-01-20T09:02:06.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>7月7号左右吧，突然接到了一个陌生的电话，说我过了中国科学院大学的夏令营，问我参不参加，于是，我就在7月18号来到了帝都，开始了我的夏令营之旅。</p>
<p>其实本来没打算会被录取的，因为报名了一个多月了，一点消息都没有。但是最后还是有幸被选上了。</p>
<h1 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h1><p>因为网络信息中心这次活动经费不足(主要是北京住宿太贵了，四个人一晚上600)，不报销路费，于是，我买了特快T66。</p>
<p>虽然上次蓝桥杯我说再也不做绿皮车了，但是，没钱，还是要坐。</p>
<p>真TMD难受，上车对床是个带小孩的，熊孩子，吵死了，一晚上没怎么睡着，火车司机也好像有问题，各种急刹车！！！</p>
<p>火车还晚点了。10点才到中科院软件园区。报到，安排住宿。</p>
<p>跟舍友超超去吃了个饭，超超的钱包没了。。。。</p>
<p>回来就睡，5点半去集合，简单说了一下夏令营安排，晚上回宿舍，看柯南，睡觉~</p>
<a id="more"></a>
<h1 id="听报告"><a href="#听报告" class="headerlink" title="听报告"></a>听报告</h1><p>因为经费没了，所以就不能出去参观了怀柔校区了，也不能去鸟巢水立方了。。。</p>
<p>安安稳稳的在报告厅听报告吧。</p>
<p>不过马石庄书记讲的还是蛮不错的，感觉受益匪浅，虽然实际上也没记住啥。</p>
<p>后面的报告就挺无聊的了，听了一天半的报告，睡了估计一天吧。。。</p>
<h1 id="笔试-amp-面试"><a href="#笔试-amp-面试" class="headerlink" title="笔试&amp;面试"></a>笔试&amp;面试</h1><p>四天上午笔试，参观，下午面试，晚上晚会。</p>
<p>笔试分为<strong>性格测试</strong>和<strong>专业测试</strong><br>专业题目应该说<strong>会的不难，难的不会</strong>，反正大数据啊，超算啊，我都不会，没接触过。后面还有什么高斯消元什么的。很高深的。</p>
<p>这个题目不需要全部做完的，基本上是面试老师用来了解你水平的，你只需要把你想去的方向的题目做好就行了，其他的题目你都不用去写。</p>
<p>我会的都是计算机网络的的部分。什么算一下子网啊，问HTTP协议的基本流程啊什么的。题目很基础，但是比较细。</p>
<p>个人感觉，性格测试比专业题目难多了。反正各种抓耳挠腮的去编。</p>
<p>下午面试，第一个问题，你六级没过啊，考了几次啊？<br>最后一个问题，你排名十几，到底能不能保研啊？<br>一把盐洒在伤口上。。。。</p>
<p>中间的问题基本上就是SDN的东西，因为我报的就是这个方向。问的也不是太多，主要是SDN大赛的事情。</p>
<p>主要是真正去研究过这方面，知道的比其他人多，所以就过了。</p>
<h1 id="晚会"><a href="#晚会" class="headerlink" title="晚会"></a>晚会</h1><p>无聊，回去很斐斐视频了。</p>
<h1 id="回学校"><a href="#回学校" class="headerlink" title="回学校"></a>回学校</h1><p>在北京的时候下暴雨，伞还丢了，会去的路上特别热！</p>
<p>还是高铁舒服，打死不坐绿皮车！</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>还是不错吧，真个过程有点赶，天气也不好，柯南二十周年漫展也没法去看，不过结果是好的，拿到了想要的Offer，还想去山大、南大那边看看，想跟斐斐一块上研究生。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;7月7号左右吧，突然接到了一个陌生的电话，说我过了中国科学院大学的夏令营，问我参不参加，于是，我就在7月18号来到了帝都，开始了我的夏令营之旅。&lt;/p&gt;
&lt;p&gt;其实本来没打算会被录取的，因为报名了一个多月了，一点消息都没有。但是最后还是有幸被选上了。&lt;/p&gt;
&lt;h1 id=&quot;出发&quot;&gt;&lt;a href=&quot;#出发&quot; class=&quot;headerlink&quot; title=&quot;出发&quot;&gt;&lt;/a&gt;出发&lt;/h1&gt;&lt;p&gt;因为网络信息中心这次活动经费不足(主要是北京住宿太贵了，四个人一晚上600)，不报销路费，于是，我买了特快T66。&lt;/p&gt;
&lt;p&gt;虽然上次蓝桥杯我说再也不做绿皮车了，但是，没钱，还是要坐。&lt;/p&gt;
&lt;p&gt;真TMD难受，上车对床是个带小孩的，熊孩子，吵死了，一晚上没怎么睡着，火车司机也好像有问题，各种急刹车！！！&lt;/p&gt;
&lt;p&gt;火车还晚点了。10点才到中科院软件园区。报到，安排住宿。&lt;/p&gt;
&lt;p&gt;跟舍友超超去吃了个饭，超超的钱包没了。。。。&lt;/p&gt;
&lt;p&gt;回来就睡，5点半去集合，简单说了一下夏令营安排，晚上回宿舍，看柯南，睡觉~&lt;/p&gt;
    
    </summary>
    
      <category term="夏令营" scheme="http://whaoyu.com/categories/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
    
      <category term="中国科学院大学" scheme="http://whaoyu.com/tags/%E4%B8%AD%E5%9B%BD%E7%A7%91%E5%AD%A6%E9%99%A2%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="夏令营" scheme="http://whaoyu.com/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
      <category term="帝都" scheme="http://whaoyu.com/tags/%E5%B8%9D%E9%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>华为实习日志</title>
    <link href="http://whaoyu.com/2016/07/11/huawei/"/>
    <id>http://whaoyu.com/2016/07/11/huawei/</id>
    <published>2016-07-11T13:23:02.000Z</published>
    <updated>2017-01-20T09:02:07.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近面试成功了华为，并加入了暑期实习，6号去报到的，7号开始上班，在这里做个每日总结。<br>尽量每天写吧。</p>
<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><p>本来想每天一篇的，但是前几天实在是太无聊了，就坐在那里玩手机发呆。</p>
<p>第一天，没装备，发了一天呆；还没带杯子，喝水都没地方。。。</p>
<p>第二天，下雨，华为<strong>第一次</strong>因为天气放假。。。不过估计还会补回来的。</p>
<p>第三天，领了自己的装备，终于有电脑了，但是没网线，去后勤要，结果没10M的网线了，让我们自己接一根。。。。<br>于是自己动手接了两个水晶头。绿白、绿、橙白、蓝、蓝白、橙、棕白、棕。我现在还记得顺序呢！装了一下自己要用的软件，一天就结束了。。。</p>
<a id="more"></a>
<h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><p>开始进行MiniTask任务，不过由于我是FX计划的实习生，因此我不用参与实习结束的答辩，所以呢，我可以划划水。</p>
<p>但是划水毕竟是不好的，而且又不是不会，因此，我还是动手做一下吧。</p>
<p>第〇步，用SVN下载源码。lib代码下载成功，适配代码下载无权限。。。。一脸血崩。<br>老司机要权限，结果，，，你先用别人的吧。。。。。。。</p>
<p>下载好代码，在编译环境编译运行，咦，我的编译机怎么登不上？！<br>问老司机，老司机找了半天错误，，，结果发现把我的工号少打了一个<strong>w</strong></p>
<p>之后顺利编译，然后去找执行机，还是没有！！！ 原来我在公司是个隐形人啊。<br>老司机说，先用别人的吧。。。</p>
<p>终于经过艰难的奋斗后，我的整个环境才算搭建好。</p>
<p>PS:PC-Lint还没有装。。。。。</p>
<p>听说我们部门的PC-Lint跟别的部门都<strong>不一样</strong>。。。。</p>
<p>第一步，注册任务。我把MiniTask模块挂在到AM模块(我也不知道这是啥模块)，弄了半天才知道lib代码要改，适配代码也要改，两边还要同步。。。。<br>经过半天的努力，终于改完了，但是呢。。。怎么把代码提交到编译环境？！没有Git，SVN没有权限！！！</p>
<p>后来，老司机说，用beyond compare吧，然后<br>lib代码比较了3个小时，适配代码比较了7个小时，一天就过去了。。。。</p>
<p>终于把代码弄上去了，编译了，改了错，最终运行了。。。。</p>
<p>第二步，去申请IPC通道。大家都发现，IPC通道申请失败，为啥呢？原来预留的IPC通道已经被之前的模块用完了，所以就申请不到了。。。。</p>
<p>好吧，然后就等老员工把不用的模块都删掉，我们再尝试。</p>
<p>这周就这样结束了。</p>
<p>最后，周六要加班，，，听说是看电影，，，《大鱼海棠》。<br>结果到了电影院，才发现是开会，在电影院开会。。。</p>
<p>喝了一碗南研HR的Boss武总的鸡汤，感觉动力满满，不过下周就去帝都了，这鸡汤也就没啥用了。</p>
<p>最后看完了电影，也不管饭，下午还要继续上班。。。。</p>
<p>果然华为不会那么好心的让你看电影</p>
<h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1><p>本周去了帝都，参加中国科学院大学夏令营，具体情况请看<a href="https://whaoyu.com/2016/07/24/ZhongkeyuanXialingying/">帝都夏令营之旅</a></p>
<p>周五晚上回来的，周六被蕾姐喊去加班，，还没有加班费。幸好说报销车费，还管饭，否则我肯定不去。。</p>
<p>第二天，早上我到公司了，她还没到，我看了一下自己的邮箱，处理了一下这一周的消息，发现，TMD适配代码改了！</p>
<p>我还要重新改适配代码！！！！！！</p>
<p>幸好我上周走的时候留了记录，改起来应该挺快的。</p>
<p>下载代码，TMD我还是没有权限！！！！</p>
<p>打电话把老司机从被窝里叫了起来，开了权限，下载。。。</p>
<p>重新编译运行，没问题。</p>
<p>然后就教了一天的Python。</p>
<p>中午，跟导师聊天，导师还是建议我去读研究生，说本科升中层的时候，会有劣势。</p>
<p>我也是这么想的。还是要去读研的。拿到了中科院信息网络中心的offer，还想再去试试南大的。</p>
<p>晚上打车，TMD Uber司机竟然不开空调，果断举报。生气~</p>
<p>本周结束！</p>
<h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><p>这周末好像要去华为的X·Summer夏令营，不知道是什么体验，下周应该就会知道了。</p>
<p>这周主要任务不是Mini Task，而是一个Python的项目，主要是给交换机命令行升级用的。之前已经有人做过了，不过个人感觉，框架写的好差。<br>整个工程全部是正则匹配，而且是以行处理的。</p>
<p>学完了编译原理，感觉这个任务用自动机实现，效果会好很多，有足够的扩展性，以文件为单位处理，效率更高。</p>
<p>不过前人做好了框架，那就得用啊。</p>
<p>各种正则匹配，还总是因为多一个空格或少一个空格匹配不到。</p>
<h1 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近面试成功了华为，并加入了暑期实习，6号去报到的，7号开始上班，在这里做个每日总结。&lt;br&gt;尽量每天写吧。&lt;/p&gt;
&lt;h1 id=&quot;第一周&quot;&gt;&lt;a href=&quot;#第一周&quot; class=&quot;headerlink&quot; title=&quot;第一周&quot;&gt;&lt;/a&gt;第一周&lt;/h1&gt;&lt;p&gt;本来想每天一篇的，但是前几天实在是太无聊了，就坐在那里玩手机发呆。&lt;/p&gt;
&lt;p&gt;第一天，没装备，发了一天呆；还没带杯子，喝水都没地方。。。&lt;/p&gt;
&lt;p&gt;第二天，下雨，华为&lt;strong&gt;第一次&lt;/strong&gt;因为天气放假。。。不过估计还会补回来的。&lt;/p&gt;
&lt;p&gt;第三天，领了自己的装备，终于有电脑了，但是没网线，去后勤要，结果没10M的网线了，让我们自己接一根。。。。&lt;br&gt;于是自己动手接了两个水晶头。绿白、绿、橙白、蓝、蓝白、橙、棕白、棕。我现在还记得顺序呢！装了一下自己要用的软件，一天就结束了。。。&lt;/p&gt;
    
    </summary>
    
      <category term="实习日志" scheme="http://whaoyu.com/categories/%E5%AE%9E%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="实习" scheme="http://whaoyu.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="华为" scheme="http://whaoyu.com/tags/%E5%8D%8E%E4%B8%BA/"/>
    
  </entry>
  
  <entry>
    <title>动手写语法分析器</title>
    <link href="http://whaoyu.com/2016/05/27/parser/"/>
    <id>http://whaoyu.com/2016/05/27/parser/</id>
    <published>2016-05-27T04:04:46.000Z</published>
    <updated>2017-01-20T09:02:07.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来这篇文章打算考试完之后写的，但是我懒了一下，就等到了答辩结束。</p>
<p>这次我用的Python写的，主要是以前只是用过Python，但是没有它做过项目，这次就用Python来试一下。感觉用Python开发还是蛮舒服的，短小精悍的代码，还有跨平台。</p>
<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>Create a phaser analysis program, which uses LL(1) method, Operator precedence analyzing or LR(1) method.<br>The inputs of the program are a text document including a set of productions of the 2º grammar (context free grammar) and the token table generated by Task 1. The out of the program is YES or NO. i.e., the source code string accords with this 2º grammar or the source code string doesn’t accord with this 2º grammar.</p>
<p>要求是用LL(1)或者LR(1)方法，这次读入的是2型文法（词法分析器是3型文法），也就是上下文无关文法。<br>源代码符合输入的文法，就输出YES，否则就输出NO，并给出错误的位置。</p>
<h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><p>在语法分析中，主要完成以下几个操作：</p>
<ul>
<li>First函数：用来求解FIRST集</li>
<li>Closure函数：用来求解某个项目的闭包</li>
<li>Go函数：将LR(1)的小圆点向后移动一位</li>
<li>GetItemSet函数：用来根据一个项目集和一个符号(终结符或非终结符)生成另一个项目集</li>
<li>MakeTable函数：用来生成ACTION表和GOTO表</li>
</ul>
<p>其实这几个函数，在课本中都有叙述，你只需要将课本上用文字描述的语言转换成C++、Java或Python就可以了。下面就一个一个的看看这些函数怎么转换。</p>
<a id="more"></a>
<h3 id="First函数"><a href="#First函数" class="headerlink" title="First函数"></a>First函数</h3><p>LR(1)使用FIRST集作为向前搜索符号集，取代了SLR(1)中的FOLLOW集。<br>First集的求解方法是在LL(1)中讲到的。<br>$$FIRST(\alpha)=\lbrace\alpha|\alpha\buildrel*\over\Rightarrow\alpha\beta,\alpha\in V_T,\alpha,\beta\in V^*\rbrace$$<br>其实简单来说，$FIRST(\alpha)$就是求的$\alpha$可以推导出的句子的第一个终结符，当$\alpha\buildrel*\over\Rightarrow\epsilon$，则规定$\epsilon\in FIRST(\alpha)$。<br>因此，当$\alpha\buildrel*\over\Rightarrow\epsilon$时，$FIRST(\alpha\beta)=FIRST(\beta)$<br>因此，<strong>FIRST函数相当于一个DFS</strong>，但是注意要<strong>标记</strong>走过的路径，否则可能无限递归到爆栈。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># items是一个list，例如：['E','+', 'T']</span></div><div class="line"><span class="comment"># visit是一个空set，用来标记走过的路径</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, items, visit)</span>:</span></div><div class="line">	<span class="comment"># 求First集</span></div><div class="line">	res = []</div><div class="line">	<span class="keyword">if</span> items[<span class="number">0</span>] <span class="keyword">in</span> visit:		<span class="comment"># item为空</span></div><div class="line">		<span class="keyword">return</span> (res, <span class="keyword">False</span>)</div><div class="line">	empty = <span class="keyword">True</span>				<span class="comment"># empty标记子节点是否为空</span></div><div class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">		<span class="keyword">if</span> empty == <span class="keyword">False</span>:</div><div class="line">			<span class="keyword">return</span> (res, <span class="keyword">False</span>)</div><div class="line">		<span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> self.vn:		<span class="comment"># 当前字符为终结符时，结束搜索</span></div><div class="line">			res.append(item)</div><div class="line">			<span class="keyword">return</span> (res, <span class="keyword">False</span>)</div><div class="line">		empty = <span class="keyword">False</span></div><div class="line">		<span class="keyword">for</span> der <span class="keyword">in</span> self.grammar[item]:	<span class="comment"># 访问子节点</span></div><div class="line">			<span class="keyword">if</span> len(der) == <span class="number">0</span>:		<span class="comment"># 判空</span></div><div class="line">				empty = <span class="keyword">True</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">			visit.add(item)			<span class="comment"># 标记访问</span></div><div class="line">			(ans, flag) = self.first(der, visit)	<span class="comment"># 访问子节点</span></div><div class="line">			res += ans</div><div class="line">			temp = set(res)</div><div class="line">			res = list(temp)</div><div class="line">			visit.remove(item)</div><div class="line">			<span class="keyword">if</span> flag == <span class="keyword">True</span>:</div><div class="line">				empty = <span class="keyword">True</span></div><div class="line">	<span class="keyword">return</span> (res, empty)	<span class="comment"># 返回first集，并返回是否为空</span></div></pre></td></tr></table></figure>
<h3 id="Closure函数"><a href="#Closure函数" class="headerlink" title="Closure函数"></a>Closure函数</h3><p>闭包定义：</p>
<ol>
<li>假定$I$是一个项目集，$I$的任何项目都属于$Closure(I)$</li>
<li>若有项目$A\Rightarrow\alpha∙B\beta, \alpha$，属于$Closure(I)$，$B\Rightarrow\gamma$是文法中的产生式，$\beta\in V^*$，$b\in FIRST(\beta\alpha)$，则$B\Rightarrow∙\gamma, b$<br>在这里，我的Closure函数并没有计算一个项目集的闭包，而是计算的单个项目的闭包，对于整个项目集的操作，我放到了<a href="#GetItemSet函数">GetItemSet</a>这个函数中</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># derivation表示一个项目 &#123;'data':('E', 'E', '+', 'T',), 'pointPosition':1, 'flag':firstSet&#125;</span></div><div class="line"><span class="comment"># visit为一个空set，用来标记是否已经加入闭包</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">closer</span><span class="params">(self, derivation, visit)</span>:</span></div><div class="line">	<span class="comment"># 获得从一个项目获得一串新的项目</span></div><div class="line">	res = []</div><div class="line">	<span class="comment"># 空项目集  已经加入项目集    不需要求闭包</span></div><div class="line">	<span class="keyword">if</span> len(derivation) == <span class="number">0</span> <span class="keyword">or</span> \</div><div class="line">		len(derivation[<span class="string">'data'</span>]) == <span class="number">0</span> <span class="keyword">or</span> \</div><div class="line">		hash(derivation[<span class="string">'data'</span>]) <span class="keyword">in</span> visit :</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">		id = self.getItemHash(derivation)		<span class="comment"># 将自己加入闭包中</span></div><div class="line">	<span class="keyword">if</span> id <span class="keyword">not</span> <span class="keyword">in</span> visit:</div><div class="line">		visit.add(id)</div><div class="line">		res.append(derivation)</div><div class="line">			</div><div class="line">	<span class="keyword">if</span> len(derivation[<span class="string">'data'</span>]) &lt;= derivation[<span class="string">'pointPosition'</span>]: </div><div class="line">		<span class="keyword">return</span> res  <span class="comment"># 小圆点在最后的 返回自身</span></div><div class="line">	</div><div class="line">	<span class="keyword">if</span> derivation[<span class="string">'data'</span>][derivation[<span class="string">'pointPosition'</span>]] <span class="keyword">in</span> self.vn:</div><div class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> self.grammar[derivation[<span class="string">'data'</span>][derivation[<span class="string">'pointPosition'</span>]]]:</div><div class="line">			newItem = [derivation[<span class="string">'data'</span>][derivation[<span class="string">'pointPosition'</span>]]] + list(item)</div><div class="line">			firstSet = []</div><div class="line">			<span class="keyword">for</span> flag <span class="keyword">in</span> derivation[<span class="string">'flag'</span>]:		<span class="comment"># 对每一个向前搜索符组成的子句进行first集求解</span></div><div class="line">				firstSet += self.first(tuple(list(derivation[<span class="string">'data'</span>][derivation[<span class="string">'pointPosition'</span>] + <span class="number">1</span>:]) + [flag]), set())[<span class="number">0</span>]</div><div class="line">			firstSet = set(firstSet)</div><div class="line">			firstSet = list(firstSet)</div><div class="line">			item = &#123;</div><div class="line">				<span class="string">'data'</span>:tuple(newItem),</div><div class="line">				<span class="string">'pointPosition'</span>:<span class="number">1</span>,</div><div class="line">				<span class="string">'flag'</span>:firstSet</div><div class="line">			&#125;</div><div class="line">			id = self.getItemHash(item)</div><div class="line">			newRes = []</div><div class="line">			<span class="keyword">if</span> id <span class="keyword">not</span> <span class="keyword">in</span> visit:		<span class="comment"># 判断是否已经加入了闭包中</span></div><div class="line">				visit.add(id)</div><div class="line">				res.append(item)</div><div class="line">				newRes = self.closer(item, visit)</div><div class="line">			res += newRes</div><div class="line">	<span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h3 id="GO函数"><a href="#GO函数" class="headerlink" title="GO函数"></a>GO函数</h3><p>Go操作就是将一个项目集的所有小圆点向后移动一位(如果小圆点不在最后面的话)。<br>具体定义如下：<br>$GO(I, X)=CLOSURE(J)$<br>其中，$I$是LR(1)中的项目集，$X$是文法符号(终结符和非终结符)。<br>$J=\{任何形如[A\Rightarrow\alpha X∙\beta, \alpha]的项目|[A\Rightarrow\alpha∙X\beta, \alpha\in I\}$<br>文法的初始项目集为$[S’\Rightarrow∙S, \#]$，然后由初始项目集通过闭包函数和转移函数，生成所有的项目集。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(self, item, v)</span>:</span></div><div class="line">	<span class="comment"># 圆点后移一位</span></div><div class="line">	item = copy.copy(item)		<span class="comment"># 由于Python的原因，list和dic作为参数，都是传递的引用，因此要在这里进行copy</span></div><div class="line">	res = []</div><div class="line">	<span class="keyword">if</span> item[<span class="string">'pointPosition'</span>] &lt; len(item[<span class="string">'data'</span>]):		<span class="comment"># 小圆点不再最后</span></div><div class="line">		<span class="keyword">if</span> item[<span class="string">'data'</span>][item[<span class="string">'pointPosition'</span>]] != v:	</div><div class="line">			<span class="keyword">return</span> res									<span class="comment"># 不符合转移条件</span></div><div class="line">		item[<span class="string">'pointPosition'</span>] += <span class="number">1</span></div><div class="line">		newItems = self.closer(item, set())</div><div class="line">		res += newItems</div><div class="line">	<span class="keyword">return</span> res</div></pre></td></tr></table></figure></p>
<h3 id="GetItemSet函数"><a href="#GetItemSet函数" class="headerlink" title="GetItemSet函数"></a>GetItemSet函数</h3><p>GetItemSet就是对一个项目集的所有项目，做一个转移和闭包操作(闭包操作在GO函数中)。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItemSet</span><span class="params">(self, items, v)</span>:</span></div><div class="line">	newItems = []</div><div class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">		newItems += self.go(item, v)</div><div class="line">	<span class="keyword">return</span> newItems</div></pre></td></tr></table></figure>
<h3 id="MakeTable函数"><a href="#MakeTable函数" class="headerlink" title="MakeTable函数"></a>MakeTable函数</h3><p>通过这个函数来生成Action表和Goto表，程序很长，但是并不复杂</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeTable</span><span class="params">(self)</span>:</span></div><div class="line">	<span class="comment"># 生成项目集 ACTION表 GOTO表</span></div><div class="line">	self.grammar.setdefault(<span class="string">'begin-1'</span>, [(self.begin,)])</div><div class="line">	</div><div class="line">	<span class="comment"># 给推导式编号</span></div><div class="line">	<span class="keyword">for</span> vn, exp <span class="keyword">in</span> self.grammar.items():</div><div class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> exp :</div><div class="line">			temp = [vn]</div><div class="line">			temp += list(item)</div><div class="line">			self.hashSet.setdefault(hash(tuple(temp)), tuple(temp))		<span class="comment"># 通过其哈希值，直接作为其编号</span></div><div class="line">	</div><div class="line">	<span class="comment"># 构造初始项目集</span></div><div class="line">	initItem = &#123;</div><div class="line">		<span class="string">'data'</span>:(<span class="string">'begin-1'</span>, self.begin),</div><div class="line">		<span class="string">'pointPosition'</span>:<span class="number">1</span>,</div><div class="line">		<span class="string">'flag'</span>:[<span class="string">'$end'</span>]</div><div class="line">	&#125;	</div><div class="line">	initItemSet = &#123;</div><div class="line">		<span class="string">'id'</span>:self.getItemSetHash(self.closer(initItem, set())),</div><div class="line">		<span class="string">'data'</span>:self.closer(initItem, set())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment"># 获取ACC标志</span></div><div class="line">	self.accflag = hash(initItem[<span class="string">'data'</span>])</div><div class="line">	</div><div class="line">	<span class="comment"># 获取语法分析的初始状态</span></div><div class="line">	self.parserBegin = initItemSet[<span class="string">'id'</span>]</div><div class="line">	</div><div class="line">	self.c = []		<span class="comment"># c用来存放所有的项目集</span></div><div class="line">	self.c.append(initItemSet)</div><div class="line">	</div><div class="line">	visit = set() 	<span class="comment"># 判断项目集是否重复</span></div><div class="line">	visit.add(initItemSet[<span class="string">'id'</span>])</div><div class="line">	<span class="keyword">for</span> items <span class="keyword">in</span> self.c:</div><div class="line">		<span class="keyword">for</span> v <span class="keyword">in</span> self.v:</div><div class="line">			res = self.getItemSet(items[<span class="string">'data'</span>], v)</div><div class="line">			<span class="keyword">if</span> len(res) == <span class="number">0</span>:		<span class="comment"># 生成了空项目集</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">				</div><div class="line">			newItemSet = &#123;</div><div class="line">				<span class="string">'id'</span>:self.getItemSetHash(res),</div><div class="line">				<span class="string">'data'</span>:res</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="comment"># 构造GOTO表</span></div><div class="line">			<span class="keyword">if</span> v <span class="keyword">in</span> self.vn:</div><div class="line">				self.goto.setdefault(items[<span class="string">'id'</span>], &#123;&#125;)</div><div class="line">				self.goto[items[<span class="string">'id'</span>]].setdefault(v, newItemSet[<span class="string">'id'</span>])</div><div class="line">				</div><div class="line">			<span class="comment"># 构造部分ACTION表  状态转移，用flag=s区分</span></div><div class="line">			<span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> self.vn:</div><div class="line">				self.action.setdefault(items[<span class="string">'id'</span>], &#123;&#125;)</div><div class="line">				self.action[items[<span class="string">'id'</span>]].setdefault(v, &#123;&#125;)</div><div class="line">				self.action[items[<span class="string">'id'</span>]][v] = &#123;</div><div class="line">					<span class="string">'flag'</span>:<span class="string">'s'</span>,	</div><div class="line">					<span class="string">'data'</span>:newItemSet[<span class="string">'id'</span>]</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				</div><div class="line">			<span class="keyword">if</span>  newItemSet[<span class="string">'id'</span>] <span class="keyword">not</span> <span class="keyword">in</span> visit:</div><div class="line">				visit.add(newItemSet[<span class="string">'id'</span>])</div><div class="line">				self.c.append(newItemSet)</div><div class="line">	</div><div class="line">	<span class="comment"># 构造ACTION表  归约，用flag=r区分</span></div><div class="line">	<span class="keyword">for</span> itemSet <span class="keyword">in</span> self.c:</div><div class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> itemSet[<span class="string">'data'</span>]:</div><div class="line">			<span class="keyword">if</span> item[<span class="string">'pointPosition'</span>] &gt;= len(item[<span class="string">'data'</span>]):</div><div class="line">				id = hash(item[<span class="string">'data'</span>])</div><div class="line">				self.action.setdefault(itemSet[<span class="string">'id'</span>], &#123;&#125;)</div><div class="line">				<span class="keyword">for</span> v <span class="keyword">in</span> item[<span class="string">'flag'</span>]:</div><div class="line">					self.action[itemSet[<span class="string">'id'</span>]].setdefault(v, &#123;&#125;)</div><div class="line">					self.action[itemSet[<span class="string">'id'</span>]][v] = &#123;</div><div class="line">						<span class="string">'flag'</span>:<span class="string">'r'</span>,</div><div class="line">						<span class="string">'data'</span>:id</div><div class="line">					&#125;</div></pre></td></tr></table></figure>
<h2 id="语法分析过程"><a href="#语法分析过程" class="headerlink" title="语法分析过程"></a>语法分析过程</h2><p>分析过程跟课本上说的一样，构造状态栈、符号栈，通过Action表和GOTO表进行状态转移和归约。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parser</span><span class="params">(self)</span>:</span></div><div class="line">	<span class="comment"># 进行语法分析</span></div><div class="line">	self.makeTable()</div><div class="line">	<span class="comment"># 初始化</span></div><div class="line">	signal = []		<span class="comment"># 符号栈</span></div><div class="line">	stateStack = []	<span class="comment"># 状态栈</span></div><div class="line">	stateStack.append(self.parserBegin)</div><div class="line">	</div><div class="line">	self.tokens.append([<span class="number">0</span>, <span class="number">0</span>, <span class="string">'$end'</span>, <span class="string">'EOF'</span>])</div><div class="line">	</div><div class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">		token = self.tokens[<span class="number">0</span>][<span class="number">2</span>]</div><div class="line">		<span class="keyword">if</span> token == <span class="string">'$end'</span> <span class="keyword">and</span> signal[<span class="number">-1</span>] == self.begin:	<span class="comment"># 结束标志</span></div><div class="line">			<span class="keyword">break</span></div><div class="line">		<span class="keyword">if</span> token <span class="keyword">in</span> self.action[stateStack[<span class="number">-1</span>]].keys():</div><div class="line">			thisAction = self.action[stateStack[<span class="number">-1</span>]][token]</div><div class="line">			</div><div class="line">			<span class="comment"># 对可归约状态进行归约</span></div><div class="line">			<span class="keyword">if</span> thisAction[<span class="string">'flag'</span>] == <span class="string">'r'</span> <span class="keyword">and</span> thisAction[<span class="string">'data'</span>] != self.accflag:</div><div class="line">				length = len(self.hashSet[thisAction[<span class="string">'data'</span>]]) - <span class="number">1</span> 		<span class="comment"># 获取回退步数</span></div><div class="line">				<span class="keyword">if</span> length != <span class="number">0</span>:</div><div class="line">					stateStack = stateStack[<span class="number">0</span>:-length]</div><div class="line">				token = self.hashSet[thisAction[<span class="string">'data'</span>]][<span class="number">0</span>]</div><div class="line">				<span class="keyword">if</span> token <span class="keyword">in</span> self.goto[stateStack[<span class="number">-1</span>]].keys():</div><div class="line">					thisGoto = self.goto[stateStack[<span class="number">-1</span>]][token]</div><div class="line">				stateStack.append(thisGoto)</div><div class="line">				<span class="keyword">if</span> length != <span class="number">0</span>:</div><div class="line">					signal = signal[<span class="number">0</span>:-length]</div><div class="line">				signal.append(token)</div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				signal.append(token)</div><div class="line">				self.tokens.pop(<span class="number">0</span>)</div><div class="line">				stateStack.append(thisAction[<span class="string">'data'</span>])</div><div class="line">			</div><div class="line">		<span class="keyword">else</span>:		<span class="comment"># 没有可转移的状态，不符合语法规范</span></div><div class="line">			<span class="keyword">print</span> <span class="string">"Error:%s:%s %s"</span> %(self.tokens[<span class="number">0</span>][<span class="number">0</span>], self.tokens[<span class="number">0</span>][<span class="number">1</span>], self.tokens[<span class="number">0</span>][<span class="number">3</span>])</div><div class="line">			<span class="keyword">break</span></div><div class="line">	<span class="keyword">if</span> signal[<span class="number">-1</span>] == self.begin:</div><div class="line">		<span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整个语法分析最复杂的，感觉是闭包函数和First函数，需要递归操作，经常无限递归，然后程序就死了。其次就是第一次写完程序运行时，发现程序的运行速度太慢了！通过做性能分析，发现是<code>copy.deepcopy</code>函数的原因，果断放弃，换了<code>copy.copy</code>。<br>还有就是，深入了解了一下Python的参数传递的方式。</p>
<p>整个项目的源码在这里：<a href="http://git.oschina.net/873314461/parser" target="_blank" rel="external">点击查看</a></p>
<p>这个项目里不仅仅有语法分析程序，还有词法分析程序，主要是因为要统一语言，所以我把上次的词法分析器又重写了一边。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来这篇文章打算考试完之后写的，但是我懒了一下，就等到了答辩结束。&lt;/p&gt;
&lt;p&gt;这次我用的Python写的，主要是以前只是用过Python，但是没有它做过项目，这次就用Python来试一下。感觉用Python开发还是蛮舒服的，短小精悍的代码，还有跨平台。&lt;/p&gt;
&lt;h2 id=&quot;任务要求&quot;&gt;&lt;a href=&quot;#任务要求&quot; class=&quot;headerlink&quot; title=&quot;任务要求&quot;&gt;&lt;/a&gt;任务要求&lt;/h2&gt;&lt;p&gt;Create a phaser analysis program, which uses LL(1) method, Operator precedence analyzing or LR(1) method.&lt;br&gt;The inputs of the program are a text document including a set of productions of the 2º grammar (context free grammar) and the token table generated by Task 1. The out of the program is YES or NO. i.e., the source code string accords with this 2º grammar or the source code string doesn’t accord with this 2º grammar.&lt;/p&gt;
&lt;p&gt;要求是用LL(1)或者LR(1)方法，这次读入的是2型文法（词法分析器是3型文法），也就是上下文无关文法。&lt;br&gt;源代码符合输入的文法，就输出YES，否则就输出NO，并给出错误的位置。&lt;/p&gt;
&lt;h2 id=&quot;任务分析&quot;&gt;&lt;a href=&quot;#任务分析&quot; class=&quot;headerlink&quot; title=&quot;任务分析&quot;&gt;&lt;/a&gt;任务分析&lt;/h2&gt;&lt;p&gt;在语法分析中，主要完成以下几个操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First函数：用来求解FIRST集&lt;/li&gt;
&lt;li&gt;Closure函数：用来求解某个项目的闭包&lt;/li&gt;
&lt;li&gt;Go函数：将LR(1)的小圆点向后移动一位&lt;/li&gt;
&lt;li&gt;GetItemSet函数：用来根据一个项目集和一个符号(终结符或非终结符)生成另一个项目集&lt;/li&gt;
&lt;li&gt;MakeTable函数：用来生成ACTION表和GOTO表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实这几个函数，在课本中都有叙述，你只需要将课本上用文字描述的语言转换成C++、Java或Python就可以了。下面就一个一个的看看这些函数怎么转换。&lt;/p&gt;
    
    </summary>
    
      <category term="课程设计" scheme="http://whaoyu.com/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="语法分析器" scheme="http://whaoyu.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
      <category term="parser" scheme="http://whaoyu.com/tags/parser/"/>
    
      <category term="Python" scheme="http://whaoyu.com/tags/Python/"/>
    
      <category term="LR(1)" scheme="http://whaoyu.com/tags/LR-1/"/>
    
  </entry>
  
  <entry>
    <title>搭建HTTPS服务器</title>
    <link href="http://whaoyu.com/2016/05/24/ssl/"/>
    <id>http://whaoyu.com/2016/05/24/ssl/</id>
    <published>2016-05-24T12:11:22.000Z</published>
    <updated>2017-01-20T09:02:07.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近网站的多说系统出了点问题，就是必须要使用https才能请求成功，可能是多说系统升级了吧，于是乎，我就升级了一下自己的服务器，让网站支持了HTTPS，这样传输的信息就安全了，你们访问我的Blog就会更安全，虽然这里不需要登陆什么的，不会泄露你的个人信息。</p>
<h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><p>网上很多资料，说证书需要自己去生成，但是生成的证书浏览器是不认可的，尽管可以调整自己的浏览器，添加证书信任，但是其他浏览你网页的人却会得到安全警告（如下图），说你的网站不安全，因此，你需要去第三方CA认证申请一个证书。</p>
<p><img src="/2016/05/24/ssl/1.png" alt=""></p>
<p>我所知道的可以申请免费证书的CA机构有两家，分别是<a href="https://buy.wosign.com/free/#ssl" target="_blank" rel="external">沃通WoSign</a>和<a href="https://www.startssl.com/" target="_blank" rel="external">StartSSL</a>，沃通是国内的一家机构，而StartSSL是国外的，如果你的网站主要是面向国内用户，建议使用沃通的证书。不过这两家张书所有的主流浏览器都是认可的，也就不会出现上面的安全警告了。</p>
<p>我使用的是沃通的证书，免费两年，到期后可以继续免费续费，相当于永久免费。</p>
<a id="more"></a>
<p>申请界面如下：</p>
<p><img src="/2016/05/24/ssl/2.png" alt=""></p>
<p>具体申请过程很清楚，按步骤来就可以了。</p>
<p><strong>注意</strong>：不要把证书弄丢了，弄丢了需要重新申请！</p>
<p>申请到证书后，会得到一个<code>domain.zip</code>的压缩包，解压后，根据你服务器的类型，选择合适的解压。</p>
<h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>我使用的nginx服务器，所以我解压了<code>for Nginx.zip</code><br><img src="/2016/05/24/ssl/3.png" alt=""></p>
<p>将证书上传到服务器，并在nginx的安装目录下，新建一个<code>sslkey</code>的文件夹，并把解压出的两个文件<code>domain.crt</code>和<code>domain.key</code>放到<code>sslkey</code>文件夹中，nginx安装在默认位置(<code>/etc/nginx/</code>)<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo <span class="built_in">mkdir</span> /etc/nginx/sslkey</div><div class="line">sudo mv <span class="built_in">domain</span>.cre /etc/nginx/sslkey/<span class="built_in">domain</span>.crt</div><div class="line">sudo mv <span class="built_in">domain</span>.<span class="built_in">key</span> /etc/nginx/sslkey/<span class="built_in">domain</span>.<span class="built_in">key</span></div></pre></td></tr></table></figure></p>
<p>这样证书就按照好了。</p>
<h2 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h2><p>在Ubuntu上，使用以下命令：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install openssl</div></pre></td></tr></table></figure></p>
<h2 id="启动HTTPS服务"><a href="#启动HTTPS服务" class="headerlink" title="启动HTTPS服务"></a>启动HTTPS服务</h2><p>没有用过StartSSL的证书，可能在ssl的配置上，有些不同，具体情况请百度或谷歌。<br>找到Nginx的网站配置文件，一般在<code>/etc/nginx/sites-available/xxx</code>，修改这个文件。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;      <span class="comment">#将原来的 80 改成 443</span></div><div class="line">    <span class="attribute">server_name</span> blog.whaoyu.com;</div><div class="line">    </div><div class="line">    <span class="comment"># 添加以下以ssl开头的内容</span></div><div class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">ssl_certificate</span> sslkey/domain.crt;      <span class="comment"># 证书公钥</span></div><div class="line">    <span class="attribute">ssl_certificate_key</span> sslkey/domain.key;  <span class="comment"># 证书私钥</span></div><div class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</div><div class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</div><div class="line">    <span class="attribute">ssl_ciphers</span> AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;</div><div class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</div><div class="line">    </div><div class="line">    <span class="comment"># 以下内容根据不容的网站，内容是不同的，不用修改</span></div><div class="line">    <span class="attribute">index</span> index.html index.htm;</div><div class="line">    <span class="attribute">root</span> /home/ubuntu/blog;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>重启nginx服务，证书安装结束。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sudo service nginx restart</span></div></pre></td></tr></table></figure></p>
<h2 id="端口重定向"><a href="#端口重定向" class="headerlink" title="端口重定向"></a>端口重定向</h2><p>新建一个站点配置文件<code>/etc/nginx/sites-available/xxx_80</code>，用来重定向80端口<br>然后编辑文件：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">  <span class="attribute">listen</span>	  <span class="number">80</span>;</div><div class="line">  <span class="attribute">server_name</span>    domain.com;</div><div class="line">  <span class="attribute">return</span>	  <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后重启nginx服务，就可以了。<br>其端口重定向使用的是HTTP 301永久重定向实现的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到此为止，HTTPS服务器就正式搭建好了，你可以使用HTTPS(<code>https://yourdomain.com</code>)访问你的网站了。</p>
<p><del>但是有点问题就是，还是可以通过80端口访问非HTTPS版的网站，解决办法是通过端口重定向，将80号指向443端口。</del><br>现在就可以享受HTTPS的安全服务啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近网站的多说系统出了点问题，就是必须要使用https才能请求成功，可能是多说系统升级了吧，于是乎，我就升级了一下自己的服务器，让网站支持了HTTPS，这样传输的信息就安全了，你们访问我的Blog就会更安全，虽然这里不需要登陆什么的，不会泄露你的个人信息。&lt;/p&gt;
&lt;h2 id=&quot;申请证书&quot;&gt;&lt;a href=&quot;#申请证书&quot; class=&quot;headerlink&quot; title=&quot;申请证书&quot;&gt;&lt;/a&gt;申请证书&lt;/h2&gt;&lt;p&gt;网上很多资料，说证书需要自己去生成，但是生成的证书浏览器是不认可的，尽管可以调整自己的浏览器，添加证书信任，但是其他浏览你网页的人却会得到安全警告（如下图），说你的网站不安全，因此，你需要去第三方CA认证申请一个证书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/05/24/ssl/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我所知道的可以申请免费证书的CA机构有两家，分别是&lt;a href=&quot;https://buy.wosign.com/free/#ssl&quot;&gt;沃通WoSign&lt;/a&gt;和&lt;a href=&quot;https://www.startssl.com/&quot;&gt;StartSSL&lt;/a&gt;，沃通是国内的一家机构，而StartSSL是国外的，如果你的网站主要是面向国内用户，建议使用沃通的证书。不过这两家张书所有的主流浏览器都是认可的，也就不会出现上面的安全警告了。&lt;/p&gt;
&lt;p&gt;我使用的是沃通的证书，免费两年，到期后可以继续免费续费，相当于永久免费。&lt;/p&gt;
    
    </summary>
    
      <category term="环境搭建" scheme="http://whaoyu.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="nginx" scheme="http://whaoyu.com/tags/nginx/"/>
    
      <category term="HTTPS" scheme="http://whaoyu.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>DES加密算法</title>
    <link href="http://whaoyu.com/2016/05/24/des/"/>
    <id>http://whaoyu.com/2016/05/24/des/</id>
    <published>2016-05-24T02:56:33.000Z</published>
    <updated>2017-01-20T09:02:06.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近上了信息安全课，学了一点东西，感觉还蛮有趣的，在这里记录一下，DES加密算法应该是IBM研制的一种被广泛使用的对称加密算法，在这里，我们只是讨论一下<strong>简化</strong>的DES算法。</p>
<h2 id="DES算法流程"><a href="#DES算法流程" class="headerlink" title="DES算法流程"></a>DES算法流程</h2><p><img src="/2016/05/24/des/1.png" alt=""></p>
<p>请允许我盗用一下老师的图片，这个流程图还是很清楚的，但是里面的具体什么置换，怎样去置换，就在简化的DES中去讲解。</p>
<a id="more"></a>
<p>整个加密过程分为3个阶段：</p>
<ul>
<li>第一阶段进行初始置换IP，然后将明文分成两个32bit的字串——L0和R0</li>
<li>对于L0和R0进行连续的16轮迭代运算</li>
<li>将迭代后的信息进行逆置换，然后得到输出的密文。其中，逆置换是初始置换的逆运算</li>
</ul>
<h2 id="密钥的形成"><a href="#密钥的形成" class="headerlink" title="密钥的形成"></a>密钥的形成</h2><p>对于一个给定的56bit密钥，在真正参与的加密的，其实只有48bit。</p>
<ul>
<li>密钥在第一阶段时，进行置换选择PC-1，根据置换选择表，转换成新的密钥，并拆分成两部分——C0和D0</li>
<li>在第二阶段中，每次对密钥进行循环左移，然后进行置换选择PC-2，得到其中的48bit，但与到加密中。</li>
</ul>
<h2 id="初始置换"><a href="#初始置换" class="headerlink" title="初始置换"></a>初始置换</h2><p>初始置换表如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>, <span class="number">2</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>, <span class="number">4</span>,</div><div class="line"><span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>, <span class="number">6</span>,<span class="number">64</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">32</span>,<span class="number">24</span>,<span class="number">16</span>, <span class="number">8</span>,</div><div class="line"><span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>, <span class="number">3</span>,</div><div class="line"><span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>, <span class="number">5</span>,<span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>, <span class="number">7</span>,</div></pre></td></tr></table></figure></p>
<p>就是把64bit数据的第58位放到第一位，第50位放到第二位，依次类推，最后得到一个新的64bit的数据</p>
<p>来个简化的样例<br>设原始8bit数据为: 1111 0011<br>IP表为：2,6,3,1,4,8,5,7<br>那么对应的转换后的数据为：1011 1101</p>
<h2 id="迭代运算"><a href="#迭代运算" class="headerlink" title="迭代运算"></a>迭代运算</h2><p>对于每次迭代运算，都需要经过以下5个步骤：</p>
<ul>
<li>扩展置换：将32bit的字串$RE_{i-1}$扩展成48bit的数据</li>
<li>异或操作：将上一步得到的48bit数据与密钥形成中得到的48bit数据进行异或操作</li>
<li>选择置换：将异或后得到的48bit数据重新变成32bit</li>
<li>置换操作：将上一步得到的结果进行置换</li>
<li>异或操作：将$LE_{i-1}$与上一步得到的数据进行亦或，得到$RE_i$，同时，$LE<em>i=RE</em>{i-1}$</li>
</ul>
<p>具体流程图如下：</p>
<p><img src="/2016/05/24/des/2.png" alt=""></p>
<h3 id="扩展置换"><a href="#扩展置换" class="headerlink" title="扩展置换"></a>扩展置换</h3><p>跟初始置换一样，根据对应的置换表格，进行置换</p>
<p>例如4bit -&gt; 8bit置换表格为：4，1，2，3，2，1，4，3<br>对于输入数据：1011<br>输出数据为：1101 0111</p>
<h3 id="与密钥异或"><a href="#与密钥异或" class="headerlink" title="与密钥异或"></a>与密钥异或</h3><p>异或操作很简单，每一位对其，相同为0， 不同为1，不多解释了</p>
<h3 id="选择置换"><a href="#选择置换" class="headerlink" title="选择置换"></a>选择置换</h3><p>选择置换又称作S盒，是DES算法中唯一没有公开的一部分，只是给出了输入和输出，具体内部如何实现的，我们不知道。</p>
<p>简化的S盒如下所示：</p>
<p><img src="/2016/05/24/des/3.png" alt=""></p>
<p>在简化的DES算法中，我们使用两个S盒——S0和S1。</p>
<ol>
<li>将8bit的数据平均分成两部分，前半部分使用S0， 后半部分使用S1</li>
<li>对于每一部分（以前半部分为例），设为D3,D2,D1,D0，将D3，D1组成一个二进制数，并转换成十进制数A1， 将D2, D1组成一个二进制数，并转换成十进制数A2</li>
<li>以A1指定一行，A2指定一列，对应的查找S0盒，得到数据M1，同理，用后半部分查找S1可以得到M2</li>
<li>将M1,M2合并成一个M，就得到了新的4bit的数据</li>
</ol>
<p>例如，S盒如上图，对应的8bit输入数据为：1101 0111<br>前半部分: A1 = 11 -&gt; 3          A2 = 10 -&gt; 2              查表可得 M1 = 1 -&gt; 01<br>后半部分：A1 = 01 -&gt; 1          A2 = 11 -&gt; 3              查表可得 M2 = 3 -&gt; 11<br>所以转换后的数据为：0111</p>
<h3 id="置换操作"><a href="#置换操作" class="headerlink" title="置换操作"></a>置换操作</h3><p>跟初始置换差不多，不解释了</p>
<h3 id="异或操作"><a href="#异或操作" class="headerlink" title="异或操作"></a>异或操作</h3><p>应该很简单，也不多解释了</p>
<h2 id="逆置换"><a href="#逆置换" class="headerlink" title="逆置换"></a>逆置换</h2><p>逆置换是初始置换的逆过程，方法跟初始置换相同。</p>
<h2 id="关于解密"><a href="#关于解密" class="headerlink" title="关于解密"></a>关于解密</h2><p>DES算法是对称加密方法，对称加密的特点就是加解密过程相同，因此，方法跟加密完全一样，只需要将密文按同样的方法加密，就得到了明文。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近上了信息安全课，学了一点东西，感觉还蛮有趣的，在这里记录一下，DES加密算法应该是IBM研制的一种被广泛使用的对称加密算法，在这里，我们只是讨论一下&lt;strong&gt;简化&lt;/strong&gt;的DES算法。&lt;/p&gt;
&lt;h2 id=&quot;DES算法流程&quot;&gt;&lt;a href=&quot;#DES算法流程&quot; class=&quot;headerlink&quot; title=&quot;DES算法流程&quot;&gt;&lt;/a&gt;DES算法流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2016/05/24/des/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;请允许我盗用一下老师的图片，这个流程图还是很清楚的，但是里面的具体什么置换，怎样去置换，就在简化的DES中去讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://whaoyu.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="des" scheme="http://whaoyu.com/tags/des/"/>
    
      <category term="加密" scheme="http://whaoyu.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>浣熊学RYU01</title>
    <link href="http://whaoyu.com/2016/05/19/learn-ryu01/"/>
    <id>http://whaoyu.com/2016/05/19/learn-ryu01/</id>
    <published>2016-05-19T15:05:46.000Z</published>
    <updated>2017-01-20T09:02:07.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在搞SDN大赛，我们的初赛题目是使用SDN网络实现对SYN　Flood 攻击的防御，因此我就开始了SDN的学习之旅，根据旗神的推荐，我们是使用的控制器是<a href="https://github.com/osrg/ryu" target="_blank" rel="external">RYU</a>，那我们就先看看一个简单的样例吧——<code>simple_switch.py</code>(这个文件在<code>ryu/app/simple_switch_13.py</code>，在不同的版本中，最后的数字是不一样的)。</p>
<p>本文内容分来自于RYUbook这本书，是台湾RYU团队翻译的。</p>
<h2 id="类别的定义和初始化"><a href="#类别的定义和初始化" class="headerlink" title="类别的定义和初始化"></a>类别的定义和初始化</h2><p>为了实现Ryu程序，需要继承<code>ryu.base.app_manager.RyuApp</code>这个类，然后将<code>OFP_VERSION</code>设定为OpenFlow 1.3.<br>之后定义MAC地址表<code>mac_port</code>。<br>在OpenFlow协议中，有些程序需要定义在OpenFlow交换机和Controller之间的链接，比如握手(handshank)，这些东西我们会在后面讲解，暂时先不用管。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleSwitch13</span><span class="params">(app_manager.RyuApp)</span>:</span></div><div class="line">    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        super(SimpleSwitch13, self).__init__(*args, **kwargs)</div><div class="line">        self.mac_to_port = &#123;&#125;</div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="事件管理-Event-handler"><a href="#事件管理-Event-handler" class="headerlink" title="事件管理(Event handler)"></a>事件管理(Event handler)</h2><p>对于RYU来说，接受到的任何OpenFlow消息都会立即产生一个相对应得事件(Event)，而我们的RYU程序需要对这个事件进行相应的处理。<br>事件管理(Event handler)需要一个事件对象(Event Object)作为参数，并且使用<code>ryu.controller.handler.set_ev_cls</code>修饰(Decorator)函数。不懂得可以去看Python教程了。</p>
<p><code>set_ev_cls</code>需要指定事件的类别和交换机的状态参数。</p>
<p>事件的类别为<code>ryu.controller.ofp_event.EventOFP+&lt;OpenFlow讯息名称&gt;</code>，例如<code>Pack-in</code>事件，就是<code>EventOFPPacketIn</code>。具体的事件定义，请查看Ryu的API手册。<br>对于状态来说，需要指定下面的表格中的一项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ryu.controller.handler.HANDSHAKE_DISPATCHER</td>
<td style="text-align:left">交换Hello消息</td>
</tr>
<tr>
<td style="text-align:left">ryu.controller.handler.CONFIG_DISPATCHER</td>
<td style="text-align:left">接收SwitchFeatures消息</td>
</tr>
<tr>
<td style="text-align:left">ryu.controller.handler.MAIN_DISPATCHER</td>
<td style="text-align:left">一般状态</td>
</tr>
<tr>
<td style="text-align:left">ryu.controller.handler.DEAD_DISPATCHER</td>
<td style="text-align:left">连接中断</td>
</tr>
</tbody>
</table>
<h3 id="添加缺省流-Table-miss-Flow-Entry"><a href="#添加缺省流-Table-miss-Flow-Entry" class="headerlink" title="添加缺省流(Table-miss Flow Entry)"></a>添加缺省流(Table-miss Flow Entry)</h3><p>OpenFlow交换机与Controller握手完成后，会在流表中添加缺省流(Table-miss Flow Entry)，为接收<code>Packet-In</code>消息做准备。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch_features_handler</span><span class="params">(self, ev)</span>:</span></div><div class="line">    datapath = ev.msg.datapath</div><div class="line">    ofproto = datapath.ofproto</div><div class="line">    parser = datapath.ofproto_parser</div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p><code>ev.msg</code>是用来存储对应事件的OpenFlow消息类的对象，在这个例子中指的是<code>ryu.ofproto.ofproto_v1_3_parser.OFPSwitchFeatures</code>。</p>
<p><code>msg.datapath</code>是用来存储OpenFlow交换机<code>ryu.controller.controller.Datapath</code>类所对应的对象。<br>Datapath类是用来处理OpenFlow交换机的重要信息，例如：执行交换机的通讯和触发接收消息的相关事件。</p>
<p>Ryu应用程序使用的主要属性如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td>连接的OpenFlow交换机的ID</td>
</tr>
<tr>
<td style="text-align:center">ofproto</td>
<td>表示当前使用的OpenFlow版本的对应ofproto module。目前可用的参数如下：</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_3</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_4</td>
</tr>
<tr>
<td style="text-align:center">ofproto_parser</td>
<td>和ofproto一样，表示ofproto_parser module。目前可用的参数如下：</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_0_parser</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_2_parser</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_3_parser</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>ryu.ofproto.ofproto_v1_4_parser</td>
</tr>
</tbody>
</table>
<p>Ryu应用程序中Datapath类的主要方法是<code>send_msg(msg)</code>，发送OpenFlow消息。<br>msg是将要发送的OpenFlow消息，是<code>ryu.ofproto.ofproto_parser.MsgBox</code>的子类。</p>
<p>交换机本身不仅仅使用收到的Switch features消息，还会在事件被处理时添加Table-miss Flow Entry。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch_features_handler</span><span class="params">(self, ev)</span>:</span></div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div><div class="line">    </div><div class="line">    <span class="comment"># install table-miss flow Entry </span></div><div class="line">    <span class="comment"># </span></div><div class="line">    <span class="comment"># We specify NO BUFFER to max_len of the output action due to </span></div><div class="line">    <span class="comment"># OVS bug. At this moment, if we specify a lesser number, e.g., </span></div><div class="line">    <span class="comment"># 128, OVS will send Packet-In with invalid buffer_id and </span></div><div class="line">    <span class="comment"># truncated packet data. In that case, we cannot output packets </span></div><div class="line">    <span class="comment"># correctly. </span></div><div class="line">    match = parser.OFPMatch()  <span class="comment"># 定义一个match(属于OFPMatch类)，它默认可以匹配所有的包</span></div><div class="line">    actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,    <span class="comment"># 定义一个动作，将类型设置为Output Action(OFPActionOutput类)</span></div><div class="line">                                      ofproto.OFPCML_NO_BUFFER)]  <span class="comment"># 将包的目的地设为Controller， OFPCML_NO_BUFFER被定义为max_len</span></div><div class="line">    self.add_flow(datapath, <span class="number">0</span>, match, actions)  <span class="comment"># 将优先级设为0，并用add_flow()发送Flow Mod消息</span></div></pre></td></tr></table></figure>
<p>Table-miss Flow Entry的优先级为0(最低)，并且这个流表项可以匹配所有的包，而且这个流表项所的动作通常是<code>output action</code>，并且输出端指向Controller。因此，当某个包没有匹配到其他的流表项的时候，就会触发Pack-In事件。<br>即：当交换机收到Packet后，匹配流表失败，会将这个Packet发送给Table-miss Flow Entry表项所对应的端口，也就是控制器。</p>
<h3 id="Packet-In-消息"><a href="#Packet-In-消息" class="headerlink" title="Packet-In 消息"></a>Packet-In 消息</h3><p>为了接收未知包，需要对Packet-In事件管理。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></div><div class="line">    msg = ev.msg datapath = msg.datapath</div><div class="line">    ofproto = datapath.ofproto</div><div class="line">    parser = datapath.ofproto_parser</div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>OFPPacketIn类的常用属性如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>match</td>
<td>用来存储接收包的Match信息，是ryu.ofproto.ofproto_v1_3_parser.OFPMatch类</td>
</tr>
<tr>
<td>data</td>
<td>收到的包的二进制数据</td>
</tr>
<tr>
<td>total_len</td>
<td>收到的包的长度</td>
</tr>
<tr>
<td>buffer_id</td>
<td>如果收到的包是在OpenFlow交换机的Buffer中，则需要指定交换机的ID，如果不在Buffer中，则指定为ryu.ofproto.ofproto_v1_3.OFP_NO_BUFFER</td>
</tr>
</tbody>
</table>
<h3 id="更新MAC地址表"><a href="#更新MAC地址表" class="headerlink" title="更新MAC地址表"></a>更新MAC地址表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div><div class="line">    </div><div class="line">    in_port = msg.match[<span class="string">'in_port'</span>] <span class="comment"># 从OFPPacketIn类的match中得到in_port信息</span></div><div class="line">    </div><div class="line">    pkt = packet.Packet(msg.data)</div><div class="line">    eth = pkt.get_protocols(ethernet.ethernet)[<span class="number">0</span>]  <span class="comment"># 从Ethernet头中获取数据</span></div><div class="line">    </div><div class="line">    dst = eth.dst  <span class="comment"># 目的MAC地址</span></div><div class="line">    src = eth.src  <span class="comment"># 源MAC地址</span></div><div class="line"></div><div class="line">    dpid = datapath.id</div><div class="line">    self.mac_to_port.setdefault(dpid, &#123;&#125;)  <span class="comment"># 通过datapath ID区分不同的OpenFlow交换机</span></div><div class="line"></div><div class="line">    self.logger.info(<span class="string">"packet in %s %s %s %s"</span>, dpid, src, dst, in_port)</div><div class="line">    <span class="comment"># learn a mac address to avoid FLOOD next time. </span></div><div class="line">    self.mac_to_port[dpid][src] = in_port  <span class="comment"># 更新MAC地址表</span></div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<h3 id="判断包的输出端口"><a href="#判断包的输出端口" class="headerlink" title="判断包的输出端口"></a>判断包的输出端口</h3><p>若目的MAC地址在MAC地址表中，则应该判断这个包的输出端口；如果不在MAC地址表中，则OUTPUT action类应该指定flooding(OFPP_FLOOD)为输出端口。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> dst <span class="keyword">in</span> self.mac_to_port[dpid]:</div><div class="line">        out_port = self.mac_to_port[dpid][dst]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        out_port = ofproto.OFPP_FLOOD</div><div class="line">    </div><div class="line">    actions = [parser.OFPActionOutput(out_port)]</div><div class="line">    </div><div class="line">    <span class="comment"># 若找到了目的MAC地址，则添加到交换机的流表中</span></div><div class="line">    <span class="keyword">if</span> out_port != ofproto.OFPP_FLOOD:</div><div class="line">        match = parser.OFPMatch(in_port=in_port, eth_dst=dst)</div><div class="line">        self.add_flow(datapath, <span class="number">1</span>, match, actions)</div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>不同于缺省流表项(Table-miss Flow Entry)，在添加新的流表项的时候，需要指明优先级，优先级数值越大，优先级越高。同时还要指明match条件，在样例中，是指定了in_port和目的MAC地址，只要满足这个条件，就会调用这个流。</p>
<h3 id="添加对流的处理"><a href="#添加对流的处理" class="headerlink" title="添加对流的处理"></a>添加对流的处理</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_flow</span><span class="params">(self, datapath, priority, match, actions)</span>:</span></div><div class="line">    ofproto = datapath.ofproto</div><div class="line">    parser = datapath.ofproto_parser</div><div class="line"></div><div class="line">    inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,</div><div class="line">                                         actions)]</div><div class="line">    </div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>这一块没怎么看懂，看懂了再更新。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在搞SDN大赛，我们的初赛题目是使用SDN网络实现对SYN　Flood 攻击的防御，因此我就开始了SDN的学习之旅，根据旗神的推荐，我们是使用的控制器是&lt;a href=&quot;https://github.com/osrg/ryu&quot;&gt;RYU&lt;/a&gt;，那我们就先看看一个简单的样例吧——&lt;code&gt;simple_switch.py&lt;/code&gt;(这个文件在&lt;code&gt;ryu/app/simple_switch_13.py&lt;/code&gt;，在不同的版本中，最后的数字是不一样的)。&lt;/p&gt;
&lt;p&gt;本文内容分来自于RYUbook这本书，是台湾RYU团队翻译的。&lt;/p&gt;
&lt;h2 id=&quot;类别的定义和初始化&quot;&gt;&lt;a href=&quot;#类别的定义和初始化&quot; class=&quot;headerlink&quot; title=&quot;类别的定义和初始化&quot;&gt;&lt;/a&gt;类别的定义和初始化&lt;/h2&gt;&lt;p&gt;为了实现Ryu程序，需要继承&lt;code&gt;ryu.base.app_manager.RyuApp&lt;/code&gt;这个类，然后将&lt;code&gt;OFP_VERSION&lt;/code&gt;设定为OpenFlow 1.3.&lt;br&gt;之后定义MAC地址表&lt;code&gt;mac_port&lt;/code&gt;。&lt;br&gt;在OpenFlow协议中，有些程序需要定义在OpenFlow交换机和Controller之间的链接，比如握手(handshank)，这些东西我们会在后面讲解，暂时先不用管。&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SimpleSwitch13&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(app_manager.RyuApp)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, *args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        super(SimpleSwitch13, self).__init__(*args, **kwargs)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.mac_to_port = &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SDN" scheme="http://whaoyu.com/categories/SDN/"/>
    
    
      <category term="SDN" scheme="http://whaoyu.com/tags/SDN/"/>
    
      <category term="RYU" scheme="http://whaoyu.com/tags/RYU/"/>
    
  </entry>
  
  <entry>
    <title>叶庆生的上机作业01</title>
    <link href="http://whaoyu.com/2016/05/03/yeqingsheng01/"/>
    <id>http://whaoyu.com/2016/05/03/yeqingsheng01/</id>
    <published>2016-05-03T00:20:32.000Z</published>
    <updated>2017-01-20T09:02:07.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>软件工程与方法学的坑爹老师要求的作业，本来以为写个控制台的程序就好了，结果不知道是谁先开始了GUI的编程，于是，这个坑爹的作业就这样开始了。虽然比较坑，但还是学了一些东西的。</p>
<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>假设需要制造一个带有四个按钮和两个灯泡的盒子并具有以下功能：</p>
<ul>
<li>有四个按钮输入，分别称为B1，B2，B3和B4；</li>
<li>有两个灯泡作为输出，分别称为L1和L2；</li>
<li>B1是打开电源的按钮；</li>
<li>B4是关闭电源的按钮；</li>
<li>B2和B3 是操作按钮；</li>
<li>在B1被按下后及B4被按下前，系统应称为电源打开状态；</li>
<li>在B4被按下后及B1被按下前，系统应称为电源关闭状态；</li>
<li>在电源关闭状态下，B2和B3按钮不起作用；</li>
<li>在电源关闭状态下，灯应不亮；</li>
<li>从最近一次电源打开状态算起，如果B2被按下的次数比B3被按下的次数多，L1亮，否则L2亮。</li>
<li>任何时候都不能有一个以上的灯泡亮；</li>
<li>如果其中的一个灯泡出现故障，另一个灯泡应以2秒钟的间隔闪烁，而不管B2和B3的操作过程。当B4按下时，闪烁停止；当B1被按下时，闪烁重新开始。当故障被排除后闪烁停止，系统恢复正常状态。</li>
</ul>
<a id="more"></a>
<h2 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h2><h3 id="JavaFx"><a href="#JavaFx" class="headerlink" title="JavaFx"></a>JavaFx</h3><p>第一次接触Java的GUI编程，百度了一下，发现了这个东西，具体看了一下，感觉跟.Net很像，界面标记语言是fxml，.Net是xmal，标记的格式也差不多。只是控件和属性有些不同。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>由于任务要求一个灯泡损坏后，另一个要以2秒钟的间隔闪烁，所以就需要一个线程来处理这个事情，于是就找到了Timer这个Class，通过调用Timer.schedule()这个函数启动一个TimerTask的Class。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Learn</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">        timer.schedule(<span class="keyword">new</span> MyTask(), <span class="number">1000</span>, <span class="number">2000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//你想执行的部分</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h3><p>因为要操作界面，又要执行MyTask这个类，所以需要在fxml的Controller中内嵌一个MyTask类，其实跟一般的类也没什么区别，只是对外部隐藏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于类C，是不可以使用类B的。</p>
<h2 id="任务源代码"><a href="#任务源代码" class="headerlink" title="任务源代码"></a>任务源代码</h2><p>git@oschina:<a href="http://git.oschina.net/873314461/Project-YeQingsheng" target="_blank" rel="external">点击查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;软件工程与方法学的坑爹老师要求的作业，本来以为写个控制台的程序就好了，结果不知道是谁先开始了GUI的编程，于是，这个坑爹的作业就这样开始了。虽然比较坑，但还是学了一些东西的。&lt;/p&gt;
&lt;h2 id=&quot;任务要求&quot;&gt;&lt;a href=&quot;#任务要求&quot; class=&quot;headerlink&quot; title=&quot;任务要求&quot;&gt;&lt;/a&gt;任务要求&lt;/h2&gt;&lt;p&gt;假设需要制造一个带有四个按钮和两个灯泡的盒子并具有以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有四个按钮输入，分别称为B1，B2，B3和B4；&lt;/li&gt;
&lt;li&gt;有两个灯泡作为输出，分别称为L1和L2；&lt;/li&gt;
&lt;li&gt;B1是打开电源的按钮；&lt;/li&gt;
&lt;li&gt;B4是关闭电源的按钮；&lt;/li&gt;
&lt;li&gt;B2和B3 是操作按钮；&lt;/li&gt;
&lt;li&gt;在B1被按下后及B4被按下前，系统应称为电源打开状态；&lt;/li&gt;
&lt;li&gt;在B4被按下后及B1被按下前，系统应称为电源关闭状态；&lt;/li&gt;
&lt;li&gt;在电源关闭状态下，B2和B3按钮不起作用；&lt;/li&gt;
&lt;li&gt;在电源关闭状态下，灯应不亮；&lt;/li&gt;
&lt;li&gt;从最近一次电源打开状态算起，如果B2被按下的次数比B3被按下的次数多，L1亮，否则L2亮。&lt;/li&gt;
&lt;li&gt;任何时候都不能有一个以上的灯泡亮；&lt;/li&gt;
&lt;li&gt;如果其中的一个灯泡出现故障，另一个灯泡应以2秒钟的间隔闪烁，而不管B2和B3的操作过程。当B4按下时，闪烁停止；当B1被按下时，闪烁重新开始。当故障被排除后闪烁停止，系统恢复正常状态。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="课程设计" scheme="http://whaoyu.com/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="叶庆生" scheme="http://whaoyu.com/tags/%E5%8F%B6%E5%BA%86%E7%94%9F/"/>
    
      <category term="JavaFX" scheme="http://whaoyu.com/tags/JavaFX/"/>
    
      <category term="java" scheme="http://whaoyu.com/tags/java/"/>
    
      <category term="GUI" scheme="http://whaoyu.com/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>动手写词法分析器</title>
    <link href="http://whaoyu.com/2016/05/01/lexical/"/>
    <id>http://whaoyu.com/2016/05/01/lexical/</id>
    <published>2016-05-01T11:16:35.000Z</published>
    <updated>2017-01-20T09:02:07.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个学期学了编译原理，所以，本学期的课程设计就是写一个<strong>词法分析器</strong>和一个<strong>语法分析器</strong>。一个很庞大的内容啊，12周就要交，于是趁着五一假期，在宿舍里写一发。</p>
<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>Create a lexical analysis program, which supports analyzing regular grammar.<br>You must use DFA (Deterministic Finite Automata) or NFA (Nondeterministic Finite Automata) to implement this program. The inputs of the program are a text document including a set of productions of 3º grammar (the regular grammar) and a source code text document contains a set of strings to be recoganized. The output of the program is a token table which consists of 5 types token: key words, identifier, const, limiter and operator.</p>
<h2 id="准备资料"><a href="#准备资料" class="headerlink" title="准备资料"></a>准备资料</h2><p>先做一下理论知识的储备。</p>
<h3 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h3><p>设$G=(V_N, V_T, P, S)$，若P中的每一个产生式都是$A \rightarrow aB$和$A \rightarrow a$，其中A和B都是非终结符，$a \in V_T^*$，则G是<strong>3型文法</strong>或<strong>正规文法</strong></p>
<h3 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h3><p>是一种识别装置，能够准确的识别正规集，即识别正规文法所定义的语言和正规式所表达的集合。</p>
<a id="more"></a>
<h2 id="正规式到NFA"><a href="#正规式到NFA" class="headerlink" title="正规式到NFA"></a>正规式到NFA</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>读入 A-&gt;aB 或 A-&gt;a</li>
<li>若A不在map中，把A加入到map中；若A在map中，则进入第三步</li>
<li>若B不存在，则把(a, B)加入到A的multimap中，然后把B加入到map中；若B存在，则把(a, y)加入到A的multimap中</li>
<li>重复第1~3步，直到把文法全部读入</li>
</ol>
<p>我主要使用<code>map</code>和<code>multimap</code>来存储NFA。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一行表示NFA的开始状态</span></div><div class="line"><span class="comment">//我通过tuple来存储了一个三元组，表示A-&gt;aB</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;len; i++)</div><div class="line">	&#123;</div><div class="line">		A = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(grammar[i]);</div><div class="line">		a = <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(grammar[i]);</div><div class="line">		B = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(grammar[i]);</div><div class="line">		<span class="comment">//统计终结符Vn和非终结符Vt</span></div><div class="line">		vn.insert(a);</div><div class="line">		vt.insert(A);</div><div class="line">		<span class="keyword">if</span> (B != <span class="string">"###"</span>)		<span class="comment">//###表示终止状态</span></div><div class="line">			vt.insert(B);</div><div class="line"></div><div class="line">		<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; &gt;::iterator res;</div><div class="line">		res = nfa.find(A);</div><div class="line">		<span class="keyword">if</span> (res == nfa.end())</div><div class="line">		&#123;</div><div class="line">			nfa.insert(pair&lt;<span class="built_in">string</span>, <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; &gt;(A, <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;()));</div><div class="line">			res = nfa.find(A);</div><div class="line">		&#125;</div><div class="line">		res-&gt;second.insert(pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(a, B));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="NFA转DFA"><a href="#NFA转DFA" class="headerlink" title="NFA转DFA"></a>NFA转DFA</h2><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>$D([S_1, S_2, …, S_j], a) = [R_1, R_2, …, R_i]$<br>其中$\varepsilon-closure(move([S_1, S_2, …, S_j], a)) = [R_1, R_2, …, R_i]$</p>
<h3 id="最小集算法"><a href="#最小集算法" class="headerlink" title="最小集算法"></a>最小集算法</h3><p>因为在本程序中，没有$\varepsilon$，所以，$\varepsilon-closure$函数与$move$函数等价<br><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">开始，另closure(K_0)为C中的唯一成员，并且他是未被标记的</div><div class="line"><span class="keyword">while</span> C中存在未被标记的子集<span class="literal">T</span></div><div class="line">    标记<span class="literal">T</span></div><div class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> 终结符集Vn</div><div class="line">        U = closure(move(<span class="literal">T</span>, a))</div><div class="line">        <span class="keyword">if</span> U不在C中</div><div class="line">            将U作为未标记的子集加入到C中</div></pre></td></tr></table></figure></p>
<h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!c.empty())</div><div class="line">&#123;</div><div class="line">	pair&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt; t = c.front();</div><div class="line">	c.pop();								</div><div class="line">	buffer.insert(t.second);				</div><div class="line">	<span class="keyword">auto</span> pos = visit.find(t.first);</div><div class="line">	<span class="keyword">if</span> (pos != visit.end())					<span class="comment">//如果已经标记过，则跳过这个状态</span></div><div class="line">		<span class="keyword">continue</span>;</div><div class="line">	visit.insert(t.first);					<span class="comment">//标记T</span></div><div class="line">	</div><div class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; temp;</div><div class="line">	<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator i;</div><div class="line">	<span class="keyword">for</span> (i = vn.begin(); i != vn.end(); i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; u = move(t.second, *i);</div><div class="line">		<span class="keyword">auto</span> pos = buffer.find(u);</div><div class="line">		<span class="keyword">if</span> (!(findInQueue(c, u) || pos != buffer.end()) &amp;&amp; !u.empty())  <span class="comment">//判断状态U是否在C中</span></div><div class="line">		&#123;</div><div class="line">			<span class="comment">//U不在C中，插入到C中</span></div><div class="line">			hash.insert(pair&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;, <span class="keyword">int</span>&gt;(u, id));			</div><div class="line">			rhash.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt;(id, u));</div><div class="line">			c.push(pair&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt;(id++, u));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!u.empty())</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;, <span class="keyword">int</span>&gt;::iterator res = hash.find(u);</div><div class="line">			temp.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(*i, res-&gt;second));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	dfa.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt;(t.first, temp));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用DFA进行词法分析"><a href="#用DFA进行词法分析" class="headerlink" title="用DFA进行词法分析"></a>用DFA进行词法分析</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><ol>
<li>预处理: 消除空白字符，主要使用<code>std::isspace(char ch)</code>来进行判断。</li>
<li>读入下一个字符，并判断文件是否结束。</li>
<li>对终结符进行转换。</li>
<li>检查下一个字符是否符合DFA的规则。</li>
<li>若符合，则加入到buffer中。判断是否是终结状态，如果是，则修改nearestAccept，并跳到第2步；否则直接跳到第2步。</li>
<li>对于不符合规则的，退回到nearestAccept，然后提交buffer，并返回Token。</li>
</ol>
<p><strong>注意</strong>: 在进行匹配的过程中，我们遵循<strong>最长匹配优先</strong>的原则。<br>例如，当出现 abc 字符串的时候，我们的程序应该把 abc 作为一个Token，而不是把 a 或者 ab 作为一个Token。<br>因此，我们需要在程序中加入最近可接受nearestAccept变量，来记录目前最长的可接受字符串，当发生匹配错误时，应退回到nearestAccept的位置，并提交。</p>
<h3 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> Scanner::getToken()</div><div class="line">&#123;</div><div class="line">	preprocess();		<span class="comment">//预处理并初始化状态</span></div><div class="line">	bLine = line;</div><div class="line">	bColumn = column;</div><div class="line">	<span class="keyword">bool</span> stop = <span class="literal">false</span>;</div><div class="line">	nearestAccept = <span class="number">0</span>;</div><div class="line">	state = <span class="number">0</span>;</div><div class="line">	buffer.clear();</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (!stop)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">char</span> c = peekChar();	<span class="comment">//预读一个字符</span></div><div class="line">		<span class="keyword">if</span> (c == EOF)			<span class="comment">//判断文件是否结束</span></div><div class="line">		&#123;</div><div class="line">			state = <span class="number">-2</span>;</div><div class="line">			<span class="keyword">return</span> <span class="string">"EOF"</span>;</div><div class="line">		&#125;</div><div class="line">		c = transform(c);</div><div class="line">		pair&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; res = dfa.find(state);</div><div class="line">		<span class="keyword">char</span> s[<span class="number">2</span>];</div><div class="line">		s[<span class="number">0</span>] = c;</div><div class="line">		s[<span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">		<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator i = res.second.find(s);</div><div class="line">		<span class="keyword">if</span> (i == res.second.end())</div><div class="line">		&#123;						<span class="comment">//DFA中找不到可行通路</span></div><div class="line">			stop = <span class="literal">true</span>;</div><div class="line">			<span class="built_in">string</span> temp = buffer.substr(nearestAccept);</div><div class="line">			buffer.erase(nearestAccept);</div><div class="line">			nextRead.insert(<span class="number">0</span>, temp);</div><div class="line">			<span class="keyword">if</span> (nearestAccept == <span class="number">0</span>)			<span class="comment">//没有可接受字符串，报错</span></div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"错误:"</span> &lt;&lt; line &lt;&lt; <span class="string">":"</span> &lt;&lt; column &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">				state = <span class="number">-1</span>;</div><div class="line">				getNextChar();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;					<span class="comment">//字符可行，加入到buffer中，并进行状态转移</span></div><div class="line">			state = i-&gt;second;</div><div class="line">			getNextChar();</div><div class="line">			buffer.push_back(currentChar);</div><div class="line">			pair&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; res = dfa.find(state);		</div><div class="line">			i = res.second.find(<span class="string">"&amp;"</span>);</div><div class="line">			<span class="keyword">if</span> (i != res.second.end())			<span class="comment">//判断是否是终结状态</span></div><div class="line">			&#123;</div><div class="line">				nearestAccept = buffer.size();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> buffer;		<span class="comment">//返回Token</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编写目标语言的正规文法"><a href="#编写目标语言的正规文法" class="headerlink" title="编写目标语言的正规文法"></a>编写目标语言的正规文法</h2><p>我理想中的目标语言是Pascal，所以下面我所写的，是Pascal的词法规则。<br>为了简化程序的编写，我以<code>begin</code>作为NFA的起始状态，<code>&amp;</code>符号作为结束的标志，<code>!</code>作为空白字符。<br>文法的表示方式如下：<br>$A \rightarrow aB$<br>表示为: A a B<br>$A \rightarrow a$<br>表示为: A a </p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>关键字在文法中属于标识符，当确认某个Token为标识符时，还需要到关键字表中验证是否是关键字。<br>在Pascal中，标识符的要求是：</p>
<ol>
<li>以字母或下划线开始</li>
<li>只包含字母、下划线和数字</li>
<li>长度小于255</li>
<li>不区分大小写</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin </span>letter-underline identifier</div><div class="line">identifier letter-<span class="keyword">digit-underline </span>identifier</div><div class="line">identifier &amp;</div></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>Pascal中的数字表达还是比较丰富的，包括整数(100)、浮点数(1.2)、科学记数法(10.2e+5)以及十六进制的整数($ae3)。</p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">begin +|- <span class="type">integer</span><span class="number">-1</span></div><div class="line">begin digit <span class="type">integer</span></div><div class="line"><span class="type">integer</span><span class="number">-1</span> digit <span class="type">integer</span></div><div class="line"><span class="type">integer</span> digit <span class="type">integer</span></div><div class="line"><span class="type">integer</span> &amp;</div></pre></td></tr></table></figure>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">integer</span> . <span class="keyword">real</span>-<span class="number">1</span></div><div class="line"><span class="keyword">real</span>-<span class="number">1</span> digit <span class="keyword">real</span>	<span class="comment">//保证小数点后一定要有数字</span></div><div class="line"><span class="keyword">real</span> digit <span class="keyword">real</span></div><div class="line"><span class="keyword">real</span> &amp;</div></pre></td></tr></table></figure>
<h4 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="type">integer</span> e science<span class="number">-1</span></div><div class="line"><span class="type">integer</span> E science<span class="number">-1</span></div><div class="line">real e science<span class="number">-1</span></div><div class="line">real E science<span class="number">-1</span></div><div class="line">science<span class="number">-1</span> +|- science<span class="number">-2</span>		<span class="comment">//保证e和正负号后面要有数字</span></div><div class="line">science<span class="number">-1</span> digit science</div><div class="line">science<span class="number">-2</span> digit science</div><div class="line">science digit science</div><div class="line">science &amp;</div></pre></td></tr></table></figure>
<h4 id="十六进制整数"><a href="#十六进制整数" class="headerlink" title="十六进制整数"></a>十六进制整数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">begin $ X<span class="built_in">integer</span>-1</div><div class="line">X<span class="built_in">integer</span>-1 xdigit X<span class="built_in">integer</span>	//保证$后面要有数字</div><div class="line">X<span class="built_in">integer</span> xdigit X<span class="built_in">integer</span></div><div class="line">X<span class="built_in">integer</span> &amp;</div></pre></td></tr></table></figure>
<h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><p>在Pascal中，字符和字符串都是用单引号括起来的，例如: ‘a’和’abc’。<br>暂时不支持转义符，但是可以通过修改文法，使其支持此功能。</p>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">begin ' <span class="built_in">char</span>-<span class="number">1</span></div><div class="line"><span class="built_in">char</span>-<span class="number">1</span> <span class="built_in">char</span> <span class="built_in">char</span>-<span class="number">2</span></div><div class="line"><span class="built_in">char</span>-<span class="number">2</span> ' <span class="built_in">char</span></div><div class="line"><span class="built_in">char</span> &amp;</div></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">begin ' <span class="type">string</span><span class="number">-1</span></div><div class="line"><span class="type">string</span><span class="number">-1</span> char <span class="type">string</span><span class="number">-1</span></div><div class="line"><span class="type">string</span><span class="number">-1</span> ' <span class="type">string</span></div><div class="line"><span class="type">string</span> &amp;</div></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在正常的词法分析其中，注释部分应该是在预处理过程中将其消除的，但是作为一个通用的词法分析器，注释部分必须出现在文法部分中，而不能再预处理过程中处理掉。<br>Pascal中的注释分为行注释和块注释。<br>行注释是<code>(*</code>开头的，以<code>*)</code>结尾的字符，块注释是以<code>{</code>开始的，以<code>}</code>结束的字符。<br><strong>注意</strong>: 注释不遵循最长优先匹配，而是<strong>最短优先匹配</strong>，因此，只要碰到<code>*)</code>或者<code>}</code>，就会停止匹配，并返回。VC++也是这样操作的。</p>
<h4 id="行注释"><a href="#行注释" class="headerlink" title="行注释"></a>行注释</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin</span> ( <span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-1</span></div><div class="line"><span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-1</span> * <span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-2</span></div><div class="line"><span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-2</span> <span class="built_in">char</span>-<span class="keyword">no</span>-star <span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-2</span></div><div class="line"><span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-2</span> * <span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-3</span></div><div class="line"><span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-3</span> <span class="built_in">char</span>-<span class="keyword">no</span>-<span class="keyword">right</span> <span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-2</span></div><div class="line"><span class="keyword">row</span>-<span class="keyword">comment</span><span class="number">-3</span> ) <span class="keyword">row</span>-<span class="keyword">comment</span></div><div class="line"><span class="keyword">row</span>-<span class="keyword">comment</span> &amp;</div></pre></td></tr></table></figure>
<h4 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin</span> &#123; <span class="keyword">block</span>-<span class="keyword">comment</span><span class="number">-1</span></div><div class="line"><span class="keyword">block</span>-<span class="keyword">comment</span><span class="number">-1</span> <span class="built_in">char</span>-<span class="keyword">no</span>-<span class="keyword">Right</span> <span class="keyword">block</span>-<span class="keyword">comment</span><span class="number">-1</span></div><div class="line"><span class="keyword">block</span>-<span class="keyword">comment</span><span class="number">-1</span> &#125; <span class="keyword">block</span>-<span class="keyword">comment</span></div><div class="line"><span class="keyword">block</span>-<span class="keyword">comment</span> &amp;</div></pre></td></tr></table></figure>
<h3 id="界符和运算符"><a href="#界符和运算符" class="headerlink" title="界符和运算符"></a>界符和运算符</h3><p>界符和运算符都比较好处理，唯一比较困难的是<code>..</code>这个界符，因为这个符号经常出现在数字后面，如果与前面的数字不加空格等分隔，程序会把第一个<code>.</code>识别成小数点，把后面的<code>.</code>识别成句号。这个问题暂时没有解决，或许可以从语法编写上解决。有知道如何解决的可以告诉我啊~<br><strong>PS</strong>:这个问题已经解决，通过<strong>最长匹配原则</strong>，可以避免这个问题。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin</span> : colon</div><div class="line">colon &amp;</div><div class="line"></div><div class="line">colon = assignment</div><div class="line">assignment &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> . <span class="keyword">period</span></div><div class="line"><span class="keyword">period</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">period</span> . duble-<span class="keyword">period</span></div><div class="line">duble-<span class="keyword">period</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> , comma</div><div class="line">comma &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> ; semicolon</div><div class="line">semicolon &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> ^ tip</div><div class="line">tip &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> / <span class="keyword">div</span></div><div class="line"><span class="keyword">div</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> + <span class="keyword">add</span></div><div class="line"><span class="keyword">add</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> - sub</div><div class="line">sub &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> * mul</div><div class="line">mul &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> % <span class="keyword">mod</span></div><div class="line"><span class="keyword">mod</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> = equ</div><div class="line">equ &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> &lt; <span class="keyword">less</span></div><div class="line"><span class="keyword">less</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">less</span> = <span class="keyword">less</span>-equ</div><div class="line"><span class="keyword">less</span>-equ &amp;</div><div class="line"></div><div class="line"><span class="keyword">less</span> &gt; <span class="keyword">not</span>-equ</div><div class="line"><span class="keyword">not</span>-equ &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> &gt; great</div><div class="line">great &amp;</div><div class="line"></div><div class="line">great = great-equ</div><div class="line">great-equ &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> ( <span class="keyword">left</span></div><div class="line"><span class="keyword">left</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> ) <span class="keyword">right</span></div><div class="line"><span class="keyword">right</span> &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> [ <span class="keyword">left</span>-m</div><div class="line"><span class="keyword">left</span>-m &amp;</div><div class="line"></div><div class="line"><span class="keyword">begin</span> ] <span class="keyword">right</span>-m</div><div class="line"><span class="keyword">right</span>-m &amp;</div></pre></td></tr></table></figure></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>词法分析器到这里基本上是写完了，但只实现了基本的功能，具体的报错等附加功能还是比较差，因为在编写过程中，并没有考虑性能问题，所以代码执行效率比较低，特别是NFA转DFA的过程。</p>
<p>整个项目我已经上传了Git@OSChina，有兴趣的可以去下载下来研究一下。<br>本人水平有限，如果你有更好的想法或者实现方法，我们可以一起讨论。</p>
<p>项目地址：<a href="http://git.oschina.net/873314461/lexical" target="_blank" rel="external">点击查看</a></p>
<p>接下来一周要考试，语法部分等我复习完编译原理再写吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个学期学了编译原理，所以，本学期的课程设计就是写一个&lt;strong&gt;词法分析器&lt;/strong&gt;和一个&lt;strong&gt;语法分析器&lt;/strong&gt;。一个很庞大的内容啊，12周就要交，于是趁着五一假期，在宿舍里写一发。&lt;/p&gt;
&lt;h2 id=&quot;任务要求&quot;&gt;&lt;a href=&quot;#任务要求&quot; class=&quot;headerlink&quot; title=&quot;任务要求&quot;&gt;&lt;/a&gt;任务要求&lt;/h2&gt;&lt;p&gt;Create a lexical analysis program, which supports analyzing regular grammar.&lt;br&gt;You must use DFA (Deterministic Finite Automata) or NFA (Nondeterministic Finite Automata) to implement this program. The inputs of the program are a text document including a set of productions of 3º grammar (the regular grammar) and a source code text document contains a set of strings to be recoganized. The output of the program is a token table which consists of 5 types token: key words, identifier, const, limiter and operator.&lt;/p&gt;
&lt;h2 id=&quot;准备资料&quot;&gt;&lt;a href=&quot;#准备资料&quot; class=&quot;headerlink&quot; title=&quot;准备资料&quot;&gt;&lt;/a&gt;准备资料&lt;/h2&gt;&lt;p&gt;先做一下理论知识的储备。&lt;/p&gt;
&lt;h3 id=&quot;正规式&quot;&gt;&lt;a href=&quot;#正规式&quot; class=&quot;headerlink&quot; title=&quot;正规式&quot;&gt;&lt;/a&gt;正规式&lt;/h3&gt;&lt;p&gt;设$G=(V_N, V_T, P, S)$，若P中的每一个产生式都是$A \rightarrow aB$和$A \rightarrow a$，其中A和B都是非终结符，$a \in V_T^*$，则G是&lt;strong&gt;3型文法&lt;/strong&gt;或&lt;strong&gt;正规文法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;有穷自动机&quot;&gt;&lt;a href=&quot;#有穷自动机&quot; class=&quot;headerlink&quot; title=&quot;有穷自动机&quot;&gt;&lt;/a&gt;有穷自动机&lt;/h3&gt;&lt;p&gt;是一种识别装置，能够准确的识别正规集，即识别正规文法所定义的语言和正规式所表达的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="课程设计" scheme="http://whaoyu.com/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="lexical" scheme="http://whaoyu.com/tags/lexical/"/>
    
      <category term="词法分析器" scheme="http://whaoyu.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
      <category term="有限状态机" scheme="http://whaoyu.com/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
      <category term="c++" scheme="http://whaoyu.com/tags/c/"/>
    
      <category term="NFA" scheme="http://whaoyu.com/tags/NFA/"/>
    
      <category term="DFA" scheme="http://whaoyu.com/tags/DFA/"/>
    
      <category term="正规式" scheme="http://whaoyu.com/tags/%E6%AD%A3%E8%A7%84%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理实验报告</title>
    <link href="http://whaoyu.com/2016/04/10/digital-image-processing/"/>
    <id>http://whaoyu.com/2016/04/10/digital-image-processing/</id>
    <published>2016-04-10T14:57:47.000Z</published>
    <updated>2017-01-20T09:02:06.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem-1"></a>Problem-1</h1><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><p>本实验主要实现对图像的自适应滤波，滤波函数为</p>
<p>$g(x,y)=f(x,y)-\frac{5000}{\sigma_{f(x,y)^2} }(f(x,y)-m(x,y))$</p>
<p>其中，</p>
<p>$$m(x,y)=\frac19\sum_{i=-1}^1{\sum_{j=-1}^1{f(x+i, y+j)}}$$</p>
<p>$$\sigma_{f(x,y)^2}=\frac19\sum_{i=-1}^1{\sum_{j=-1}^1}{(f(x+i,y+j)-m(x,y))^2}$$</p>
<p>由公式可知，m(x,y)和$\sigma_{f(x,y)^2}$是对于点(x,y)的3×3邻域求均值和方差，于是可以直接使用MATLAB中的mean函数和var函数进行代替，直接进行运算。<br>高斯滤波，通过加权平均后，图像变的模糊，噪点有所减少，但是图像损失了大量细节；中值滤波，对于本实验所产生的椒盐噪声应该有较好的处理，但是实际上，图片的涂抹很严重，损失了大量的信息；自适应滤波，对噪点消除的不是很理想，但是保留了图片本身影响最小。我认为自适应滤波应该是本实验中还原效果最好的滤波器。<br>同时发现，程序的运行速度特别慢，大约要14秒，使用MATLAB中的计时运行后发现，主要的时间集中在mean函数上，对于500×350的图像，mean函数共调用了350000次。为优化时间，将mean函数改成求和并除以9，运行速度提升明显，只需要2.3秒左右。</p>
<h2 id="Read-image-and-Add-noise"><a href="#Read-image-and-Add-noise" class="headerlink" title="Read image and Add noise"></a>Read image and Add noise</h2><p>噪声产生公式<br>$$f(x,y)=\begin{cases}<br>255 &amp; &amp; {f_0(x, y) &gt; t_1(fx, y)} \\<br>0 &amp; &amp; {f_0(x, y) &lt; t_1(fx, y)} \\<br>f_0(x, y) &amp; &amp; {otherwise}\end{cases}$$</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">origin=imread(<span class="string">'lena.jpg'</span>);</div><div class="line">origin=rgb2gray(origin);</div><div class="line">[m,n]=<span class="built_in">size</span>(origin);</div><div class="line">t1 = <span class="built_in">round</span>(<span class="number">255</span> * <span class="built_in">rand</span>(m, n));</div><div class="line">t2 = <span class="built_in">round</span>(<span class="number">255</span> * <span class="built_in">rand</span>(m, n));</div><div class="line">origin2=origin;</div><div class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</div><div class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</div><div class="line">        <span class="keyword">if</span> origin2(<span class="built_in">i</span>,<span class="built_in">j</span>)&amp;gt;t1(<span class="built_in">i</span>,<span class="built_in">j</span>)</div><div class="line">            origin(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">255</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> origin2(<span class="built_in">i</span>,<span class="built_in">j</span>)&amp;lt;t2(<span class="built_in">i</span>,<span class="built_in">j</span>)</div><div class="line">            origin(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">0</span>;</div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">figure(<span class="number">1</span>);</div><div class="line">imshow(origin);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/1.png" alt=""></p>
<h2 id="Gaussian-filter"><a href="#Gaussian-filter" class="headerlink" title="Gaussian filter"></a>Gaussian filter</h2><p>3x3的高斯滤波器</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gaussian=fspecial(<span class="string">'gaussian'</span>,[<span class="number">3</span>,<span class="number">3</span>],<span class="number">1</span>);</div><div class="line">g1=imfilter(origin,gaussian,<span class="string">'conv'</span>,<span class="string">'symmetric'</span>);</div><div class="line">figure(<span class="number">2</span>);</div><div class="line">imshow(g1);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/2.png" alt=""></p>
<h2 id="Median-filter"><a href="#Median-filter" class="headerlink" title="Median filter"></a>Median filter</h2><p>3x3的中值滤波器</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g2=medfilt2(origin,[<span class="number">3</span>,<span class="number">3</span>]);</div><div class="line">figure(<span class="number">3</span>);</div><div class="line">imshow(g2);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/3.png" alt=""></p>
<h2 id="Adaptive-filter"><a href="#Adaptive-filter" class="headerlink" title="Adaptive filter"></a>Adaptive filter</h2><p>$$g(x,y)=f(x,y)-\frac{5000}{\sigma^2_{f(x,y)}}(f(x,y)-m(x,y))$$</p>
<p>其中,</p>
<p>$$m(x,y)=\frac19\sum\limits_{i=-1}^1\sum\limits_{j=-1}^1f(x+i,y+j)$$</p>
<p>$$\sigma^2_{f(x,y)}=\frac19\sum\limits_{i=-1}^1\sum\limits_{j=-1}^1(f(x+i,y+j)-m(x,y))^2$$</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">extendim = <span class="built_in">zeros</span>(m+<span class="number">2</span>,n+<span class="number">2</span>);</div><div class="line">extendim(<span class="number">2</span>:m+<span class="number">1</span>,<span class="number">2</span>:n+<span class="number">1</span>) = origin(:,:,<span class="number">1</span>);</div><div class="line">extendim(<span class="number">1</span>,<span class="number">2</span>:n+<span class="number">1</span>) = origin(<span class="number">1</span>,:,<span class="number">1</span>);</div><div class="line">extendim(m+<span class="number">2</span>,<span class="number">2</span>:n+<span class="number">1</span>) = origin(m,:,<span class="number">1</span>);</div><div class="line">extendim(<span class="number">2</span>:m+<span class="number">1</span>,<span class="number">1</span>) = origin(:,<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">extendim(<span class="number">2</span>:m+<span class="number">1</span>,n+<span class="number">2</span>) = origin(:,n,<span class="number">1</span>);</div><div class="line">g4 = uint8(<span class="built_in">zeros</span>(m, n));</div><div class="line">one = <span class="built_in">ones</span>(<span class="number">3</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">for</span> x = <span class="number">1</span> : m</div><div class="line">    <span class="keyword">for</span> y = <span class="number">1</span> : n</div><div class="line">        temp = extendim(x:x + <span class="number">2</span>, y: y + <span class="number">2</span>);</div><div class="line"><span class="comment">%         avg_1 = mean(mean(temp)); %相当于m(x,y)</span></div><div class="line"><span class="comment">%         d2_1 = var(temp(:), 1);      %想到与sigma_squared(x,y)</span></div><div class="line"><span class="comment">%         g4_1(x, y) = extendim(x + 1, y + 1) - (5000 / d2_1) * (extendim(x + 1, y + 1) - avg_1);</span></div><div class="line">        avg = sum(sum(temp))/<span class="number">9</span>;</div><div class="line">        d2 = (temp - avg * one).^<span class="number">2</span>;</div><div class="line">        d2 = sum(sum(d2))/<span class="number">9</span>;</div><div class="line">        g4(x, y) = extendim(x + <span class="number">1</span>, y + <span class="number">1</span>) - (<span class="number">5000</span> / d2) * (extendim(x + <span class="number">1</span>, y + <span class="number">1</span>) - avg);</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">figure(<span class="number">4</span>);</div><div class="line">imshow(g4);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/4.png" alt=""></p>
<h1 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem-2"></a>Problem-2</h1><h2 id="Matlab中imfilter函数的基本原理和数学公式"><a href="#Matlab中imfilter函数的基本原理和数学公式" class="headerlink" title="Matlab中imfilter函数的基本原理和数学公式"></a>Matlab中imfilter函数的基本原理和数学公式</h2><p>函数原型</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">G = imfilter(F, W, filtering_mode, boundary_options, size_options)</div></pre></td></tr></table></figure>
<p>其中G为输出图像，F为原图像，W为滤波器，<code>filtering_mode</code>用于指定在滤波过程中是使用“相关”还是“卷积”。<code>boundary_options</code>用于处理边界充零问题，边界的大小由滤波器的大小确定。具体参数选项见下表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filtering_mode</td>
<td>‘corr’</td>
<td>通过使用相关来完成，该值为默认。</td>
</tr>
<tr>
<td></td>
<td>‘conv’</td>
<td>通过使用卷积来完成</td>
</tr>
<tr>
<td>boundary_options</td>
<td>‘X’</td>
<td>输入图像的边界通过用值X（无引号）来填充扩展,其默认值为0</td>
</tr>
<tr>
<td></td>
<td>‘replicate’</td>
<td>图像大小通过复制外边界的值来扩展</td>
</tr>
<tr>
<td></td>
<td>‘symmetric’</td>
<td>图像大小通过镜像反射其边界来扩展</td>
</tr>
<tr>
<td></td>
<td>‘circular’</td>
<td>&gt;图像大小通过将图像看成是一个二维周期函数的一个周期来扩展</td>
</tr>
<tr>
<td>size_options</td>
<td>‘full’</td>
<td>输出图像的大小与被扩展图像的大小相同</td>
</tr>
<tr>
<td></td>
<td>‘same’</td>
<td>输出图像的大小与输入图像的大小相同。这可通过将滤波掩模的中心点的偏移限制到原图像中包含的点来实现，该值为默认值。</td>
</tr>
</tbody>
</table>
<p>函数imfilter的一半过程为：</p>
<ol>
<li>根据选项对图片进行边缘扩充，得到中间图像T</li>
<li>根据选项，对中间图像T和滤波器W进行卷积操作或者相关操作</li>
<li>根据选项，对中间图像T做调整并输出</li>
</ol>
<p>其中，<br>卷积操作的数学公式为：$G=F*W$，<br>展开后为：<br>$$G(x,y)=\sum_{i=-k}^k\sum_{j=-k}^k{f(x-i,y-j)⋅W(i,j)}$$</p>
<p>其中，2k+1为滤波器W的宽度或高度。<br>相关操作数学公式：<br>$$G=F∙W$$，<br>展开后为：<br>$$G(x,y)=\sum_{i=-k}^k\sum_{j=-k}^k{f(i-x,y-j)⋅W(i,j)}$$</p>
<p>其中，2k+1为滤波器W的宽度或高度。</p>
<h2 id="Which-of-the-three-sharpening-procedures-is-visually-more-appealing-to-you-Why"><a href="#Which-of-the-three-sharpening-procedures-is-visually-more-appealing-to-you-Why" class="headerlink" title="Which of the three sharpening procedures is visually more appealing to you? Why?"></a>Which of the three sharpening procedures is visually more appealing to you? Why?</h2><p>现象：</p>
<ul>
<li>单纯使用+8的拉普拉斯滤波器，图像的边缘非常明显，但是图片中存在大量的噪点。</li>
<li>通过高斯滤波后，图像的噪点减少，但是边缘也变的模糊。</li>
<li>-8的拉普拉斯滤波器效果比-4的滤波器效果要好，噪点较少，图像边缘较明显。</li>
</ul>
<p>原因：<br>使用高斯滤波对图像进行平滑处理，使图像中的颜色变化剧烈的部分变平滑，因此在边缘检测的时候，图像整体的噪点下降，同时，-8的滤波器对于边缘的增强效果要好于-4.</p>
<h2 id="Read-image-and-Define-filter"><a href="#Read-image-and-Define-filter" class="headerlink" title="Read image and Define filter"></a>Read image and Define filter</h2><ul>
<li>filterlap1 中心+8的拉普拉斯滤波器</li>
<li>filterlap2 中心-4的拉普拉斯滤波器</li>
<li>filterlap3 中心-8的拉普拉斯滤波器</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">im = imread(<span class="string">'Lena.jpg'</span>);</div><div class="line">im=rgb2gray(im);</div><div class="line">filterlap1 = [<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>;<span class="number">-1</span>,<span class="number">8</span>,<span class="number">-1</span>;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>];</div><div class="line">filterlap2 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">-4</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>];</div><div class="line">filterlap3 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">-8</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</div></pre></td></tr></table></figure>
<h2 id="Image-sharpening-using-the-3x3-Laplacian-filter-with-8-at-the-center"><a href="#Image-sharpening-using-the-3x3-Laplacian-filter-with-8-at-the-center" class="headerlink" title="Image sharpening using the 3x3 Laplacian filter with +8 at the center."></a>Image sharpening using the 3x3 Laplacian filter with +8 at the center.</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">im1=imfilter(im,filterlap1,<span class="string">'conv'</span>,<span class="string">'symmetric'</span>);</div><div class="line">figure(<span class="number">1</span>);</div><div class="line">imshow(im1);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/5.png" alt=""></p>
<h2 id="The-input-image-is-first-smoothed-with-the-3x3-σ-5-Gaussian-filter-The-resulting-image-is-then-sharpened-using-the-Laplacian-filter-with-4-at-the-center"><a href="#The-input-image-is-first-smoothed-with-the-3x3-σ-5-Gaussian-filter-The-resulting-image-is-then-sharpened-using-the-Laplacian-filter-with-4-at-the-center" class="headerlink" title="The input image is first smoothed with the 3x3 ,σ=5 Gaussian filter. The resulting image is then sharpened using the Laplacian filter with -4 at the center."></a>The input image is first smoothed with the 3x3 ,σ=5 Gaussian filter. The resulting image is then sharpened using the Laplacian filter with -4 at the center.</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gaussian1 = fspecial(<span class="string">'gaussian'</span>,[<span class="number">3</span>,<span class="number">3</span>],<span class="built_in">sqrt</span>(<span class="number">5</span>));</div><div class="line">im2=imfilter(im,gaussian1,<span class="string">'conv'</span>,<span class="string">'symmetric'</span>);      <span class="comment">%高斯滤波</span></div><div class="line">im2=imfilter(im2,filterlap2,<span class="string">'conv'</span>,<span class="string">'symmetric'</span>);    <span class="comment">%拉普拉斯滤波</span></div><div class="line">figure(<span class="number">2</span>);</div><div class="line">imshow(im2);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/6.png" alt=""></p>
<h2 id="The-input-image-is-first-smoothed-with-the-3x3-σ-1-Gaussian-filter-The-resulting-image-is-then-sharpened-using-the-Laplacian-filter-with-8-at-the-center"><a href="#The-input-image-is-first-smoothed-with-the-3x3-σ-1-Gaussian-filter-The-resulting-image-is-then-sharpened-using-the-Laplacian-filter-with-8-at-the-center" class="headerlink" title="The input image is first smoothed with the 3x3 , σ=1 Gaussian filter. The resulting image is then sharpened using the Laplacian filter with -8 at the center."></a>The input image is first smoothed with the 3x3 , σ=1 Gaussian filter. The resulting image is then sharpened using the Laplacian filter with -8 at the center.</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gaussian2 = fspecial(<span class="string">'gaussian'</span>, [<span class="number">3</span>, <span class="number">3</span>], <span class="number">1</span>);</div><div class="line">im3 = imfilter(im, gaussian2, <span class="string">'conv'</span>, <span class="string">'symmetric'</span>);     <span class="comment">%高斯滤波</span></div><div class="line">im3 = imfilter(im3, filterlap3, <span class="string">'conv'</span>, <span class="string">'symmetric'</span>);   <span class="comment">%拉普拉斯滤波</span></div><div class="line">figure(<span class="number">3</span>);</div><div class="line">imshow(im3);</div></pre></td></tr></table></figure>
<p><img src="/2016/04/10/digital-image-processing/7.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-1&quot;&gt;&lt;a href=&quot;#Problem-1&quot; class=&quot;headerlink&quot; title=&quot;Problem-1&quot;&gt;&lt;/a&gt;Problem-1&lt;/h1&gt;&lt;h2 id=&quot;实验分析&quot;&gt;&lt;a href=&quot;#实验分析&quot; class=&quot;headerli
    
    </summary>
    
      <category term="课程设计" scheme="http://whaoyu.com/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数字图像处理" scheme="http://whaoyu.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="MATLAB" scheme="http://whaoyu.com/tags/MATLAB/"/>
    
      <category term="自适应滤波" scheme="http://whaoyu.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
</feed>
